from __future__ import annotations

import logging
import re
from typing import Optional
from urllib.parse import urlparse
import voluptuous as vol
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import Platform, CONF_NAME
from homeassistant.core import HomeAssistant, ServiceCall
from homeassistant.helpers import device_registry as dr, config_validation as cv
from homeassistant.helpers.network import get_url
from homeassistant.components import person

from .const import (
    DOMAIN,
    CONF_ITFLOW_API_KEY,
    CONF_ITFLOW_CLIENT_ID,
    CONF_ITFLOW_SERVER,
    CONF_PUBLIC_URL,
    CONF_INTEGRATION_MODE,
    INTEGRATION_MODE_TICKETS_ONLY,
    CONF_MASTER_ACCOUNT_MODE,
    CONF_CREATE_STARTUP_TICKET,
    CONF_ALERT_ON_ERRORS,
    CONF_ALERT_ON_NEW_UPDATE,
    CONF_ALERT_ON_AUTOMATION_FAILURE,
    CONF_ALERT_ON_ERROR_LOGS,
    CONF_ALERT_ON_BACKUP_FAILURE,
    CONF_MONITOR_DISK,
    CONF_DISK_THRESHOLD,
    CONF_MONITOR_MEMORY,
    CONF_MEMORY_THRESHOLD,
    CONF_MONITOR_CPU,
    CONF_CPU_THRESHOLD,
    CONF_MONITOR_IP,
    SERVICE_CREATE_TICKET,
    CONF_HEALTH_REPORT_ENABLED,
    CONF_HEALTH_REPORT_FREQUENCY,
    HEALTH_REPORT_DAILY,
    HEALTH_REPORT_WEEKLY,
)
from .itflow_api import ITFlowClient

_PLATFORMS: list[Platform] = [Platform.SENSOR, Platform.BUTTON]

_LOGGER = logging.getLogger(__name__)


def get_ticket_footer(hass: HomeAssistant, entry: ConfigEntry) -> str:
    """Generate HTML footer with HA instance information for tickets.

    Args:
        hass: Home Assistant instance
        entry: Config entry

    Returns:
        HTML string with instance info footer
    """
    try:
        # Get instance information
        local_ip = str(hass.config.api.local_ip) if hass.config.api else "Unknown"
        public_url = entry.data.get(CONF_PUBLIC_URL, "Not configured")
        ha_instance_id = hass.data.get("core.uuid", "Unknown")

        footer_html = f"""
<hr style="margin-top: 30px; border: none; border-top: 2px solid #ddd;">
<div style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; font-size: 12px; color: #666;">
    <h4 style="margin-top: 0; color: #333;">üìç Home Assistant Instance Information</h4>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 4px 8px;"><strong>Local IP:</strong></td>
            <td style="padding: 4px 8px;">{local_ip}</td>
        </tr>
        <tr>
            <td style="padding: 4px 8px;"><strong>Public URL:</strong></td>
            <td style="padding: 4px 8px;">{public_url}</td>
        </tr>
        <tr>
            <td style="padding: 4px 8px;"><strong>Instance ID:</strong></td>
            <td style="padding: 4px 8px;"><code>{ha_instance_id}</code></td>
        </tr>
    </table>
    <p style="margin: 10px 0 0 0; font-style: italic;">
        ü§ñ This ticket was automatically generated by OnOff Support Agent
    </p>
</div>"""
        return footer_html
    except Exception as err:
        _LOGGER.error("Error generating ticket footer: %s", err)
        return "\n\nü§ñ This ticket was automatically generated by OnOff Support Agent"


async def async_setup(hass: HomeAssistant, _config: dict) -> bool:
    """Set up the integration."""
    return True

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Set up ITFlow from a config entry."""

    data = entry.data
    title = data.get(CONF_NAME, "On-Off ITFlow")

    hass.data.setdefault(DOMAIN, {})
    hass.data[DOMAIN][entry.entry_id] = {
        "title": title,
        "itflow_client": None,
        "itflow_asset_id": None,
        "itflow_contact_id": None,
        "api_key": data.get(CONF_ITFLOW_API_KEY),
        "server": data.get(CONF_ITFLOW_SERVER),
    }
    entry.runtime_data = title

    device_registry = dr.async_get(hass)
    device_registry.async_get_or_create(
        config_entry_id=entry.entry_id,
        identifiers={(DOMAIN, title)},
        manufacturer="On-Off",
        name=title,
        model="ITFlow Integration",
    )

    # Initialize ITFlow
    await setup_itflow(hass, entry)

    # Set up platforms
    await hass.config_entries.async_forward_entry_setups(entry, _PLATFORMS)

    # Register services (panel removed)
    register_services(hass, entry)
    _LOGGER.info("ITFlow services registered successfully")

    # Register frontend resources (custom cards)
    await register_frontend_resources(hass)

    return True


async def setup_itflow(hass: HomeAssistant, entry: ConfigEntry):
    """Set up ITFlow integration."""
    data = entry.data
    title = data.get(CONF_NAME, "On-Off ITFlow")

    # Create ITFlow client (server URL is now hardcoded to ticket.onoffapi.com)
    client = ITFlowClient(
        server="https://ticket.onoffapi.com",  # Hardcoded server
        api_key=data[CONF_ITFLOW_API_KEY],
        client_id=data[CONF_ITFLOW_CLIENT_ID],
    )

    hass.data[DOMAIN][entry.entry_id]["itflow_client"] = client

    try:
        # Get local IP and system info
        local_ip = str(hass.config.api.local_ip) if hass.config.api else "Unknown"

        # Get HA system information
        ha_version = hass.config.version if hasattr(hass.config, 'version') else "Unknown"

        # Get HA instance ID for tracking
        ha_instance_id = hass.data.get("core.uuid") or "Unknown"

        # Check if we already have stored asset ID
        stored_asset_id = entry.data.get("itflow_asset_id")

        # Create or update asset
        asset_name = f"HA - {title}"
        public_url = data.get(CONF_PUBLIC_URL, "")

        try:
            if stored_asset_id:
                # Update existing asset
                _LOGGER.info("Updating existing ITFlow asset ID: %s", stored_asset_id)
                asset_notes = f"HA Instance ID: {ha_instance_id}\n"
                asset_notes += f"Public URL: {public_url}\n" if public_url else ""
                asset_notes += f"Home Assistant installation: {title}"

                asset_response = await client.update_asset(
                    asset_id=stored_asset_id,
                    asset_ip=local_ip,
                    asset_notes=asset_notes
                )
                hass.data[DOMAIN][entry.entry_id]["itflow_asset_id"] = stored_asset_id
                _LOGGER.info("Updated ITFlow asset: %s", asset_name)
            else:
                # Create new asset with detailed info
                from datetime import datetime, timedelta
                today = datetime.now().strftime("%Y-%m-%d")
                warranty_expire = (datetime.now() + timedelta(days=365)).strftime("%Y-%m-%d")
                install_date = (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d")

                # Build comprehensive notes with HA instance ID
                asset_notes = f"HA Instance ID: {ha_instance_id}\n"
                asset_notes += f"Public URL: {public_url}\n" if public_url else ""
                asset_notes += f"Home Assistant installation: {title}"

                asset_response = await client.create_asset(
                    asset_name=asset_name,
                    asset_type="Server",
                    asset_ip=local_ip,
                    asset_notes=asset_notes,
                    asset_make="Home Assistant",
                    asset_model=ha_version,
                    asset_os="HassOS",
                    asset_status="Deployed",
                    asset_purchase_date=today,
                    asset_warranty_expire=warranty_expire,
                    install_date=install_date
                )

                # Handle response - it might be a dict or list
                _LOGGER.info("Asset creation response type: %s, content: %s", type(asset_response), asset_response)

                if isinstance(asset_response, dict):
                    if asset_response.get("success") or asset_response.get("success") == "True":
                        # Response data could be dict or list
                        response_data = asset_response.get("data", {})
                        _LOGGER.info("Asset response data type: %s, content: %s", type(response_data), response_data)

                        asset_id = None
                        if isinstance(response_data, list) and len(response_data) > 0:
                            asset_id = response_data[0].get("asset_id") or response_data[0].get("insert_id")
                        elif isinstance(response_data, dict):
                            asset_id = response_data.get("asset_id") or response_data.get("insert_id") or response_data.get("id")
                        elif isinstance(response_data, str):
                            # Sometimes the ID is returned as a string
                            try:
                                asset_id = int(response_data)
                            except (ValueError, TypeError):
                                pass

                        if asset_id:
                            hass.data[DOMAIN][entry.entry_id]["itflow_asset_id"] = asset_id
                            # Store asset ID in config entry for persistence
                            new_data = dict(entry.data)
                            new_data["itflow_asset_id"] = asset_id
                            new_data["first_installation"] = True  # Mark as first installation
                            hass.config_entries.async_update_entry(entry, data=new_data)
                            _LOGGER.info("Created ITFlow asset: %s (ID: %s)", asset_name, asset_id)
                        else:
                            _LOGGER.warning("Asset created but no ID returned. Response: %s", asset_response)
                    else:
                        _LOGGER.error("Asset creation failed: %s", asset_response.get("message", "Unknown error"))
                else:
                    _LOGGER.warning("Unexpected asset response type: %s, content: %s", type(asset_response), asset_response)
        except Exception as err:
            _LOGGER.error("Failed to create/update ITFlow asset: %s", err, exc_info=True)

        # Create or reuse contact (non-blocking - don't prevent integration from loading)
        stored_contact_id = entry.data.get("itflow_contact_id")
        if stored_contact_id:
            hass.data[DOMAIN][entry.entry_id]["itflow_contact_id"] = stored_contact_id
            _LOGGER.info("Reusing existing ITFlow contact ID: %s", stored_contact_id)
        else:
            _LOGGER.info("No stored contact ID found, creating new 'HA API' contact...")
            try:
                contact_response = await client.create_contact(
                    contact_name="HA API"
                )
                _LOGGER.info("Contact creation response type: %s, content: %s", type(contact_response), contact_response)

                if isinstance(contact_response, dict):
                    if contact_response.get("success") or contact_response.get("success") == "True" or contact_response.get("success") == True:
                        response_data = contact_response.get("data", {})
                        _LOGGER.info("Contact response data type: %s, content: %s", type(response_data), response_data)

                        contact_id = None
                        if isinstance(response_data, list) and len(response_data) > 0:
                            contact_id = response_data[0].get("contact_id") or response_data[0].get("insert_id") or response_data[0].get("id")
                        elif isinstance(response_data, dict):
                            contact_id = response_data.get("contact_id") or response_data.get("insert_id") or response_data.get("id")
                        elif isinstance(response_data, str):
                            # Sometimes the ID is returned as a string
                            try:
                                contact_id = int(response_data)
                            except (ValueError, TypeError):
                                pass

                        if contact_id:
                            hass.data[DOMAIN][entry.entry_id]["itflow_contact_id"] = contact_id
                            # Store contact ID
                            new_data = dict(entry.data)
                            new_data["itflow_contact_id"] = contact_id
                            hass.config_entries.async_update_entry(entry, data=new_data)
                            _LOGGER.info("‚úÖ Created ITFlow contact 'HA API' (ID: %s)", contact_id)
                        else:
                            _LOGGER.warning("‚ö†Ô∏è Contact created but no ID returned. Integration will continue without default contact. Response: %s", contact_response)
                    else:
                        _LOGGER.warning("‚ö†Ô∏è Contact creation failed: %s. Integration will continue without default contact.", contact_response.get("message", "Unknown error"))
                else:
                    _LOGGER.warning("‚ö†Ô∏è Unexpected contact response. Integration will continue without default contact. Type: %s, content: %s", type(contact_response), contact_response)
            except Exception as err:
                _LOGGER.warning("‚ö†Ô∏è Failed to create ITFlow contact, but integration will continue: %s", err, exc_info=True)

        # Create or update domain if public URL is provided
        public_url = data.get(CONF_PUBLIC_URL)
        stored_domain_id = entry.data.get("itflow_domain_id")

        if public_url:
            try:
                parsed_url = urlparse(public_url)
                domain_name = parsed_url.netloc or public_url

                if stored_domain_id:
                    # Update existing domain
                    _LOGGER.info("Updating existing ITFlow domain ID: %s", stored_domain_id)
                    domain_response = await client.update_domain(
                        domain_id=stored_domain_id,
                        domain_name=domain_name,
                        domain_ip=local_ip,
                        domain_notes="Auto-renewal enabled"
                    )
                    hass.data[DOMAIN][entry.entry_id]["itflow_domain_id"] = stored_domain_id
                    _LOGGER.info("Updated ITFlow domain: %s", domain_name)
                else:
                    # Create new domain with detailed info
                    domain_response = await client.create_domain(
                        domain_name=domain_name,
                        domain_webhost="SiteGround",
                        domain_ip=local_ip,
                        domain_notes="Auto-renewal enabled"
                    )

                    if isinstance(domain_response, dict) and domain_response.get("success"):
                        response_data = domain_response.get("data", {})
                        if isinstance(response_data, list) and len(response_data) > 0:
                            domain_id = response_data[0].get("domain_id") or response_data[0].get("insert_id")
                        elif isinstance(response_data, dict):
                            domain_id = response_data.get("domain_id") or response_data.get("insert_id")
                        else:
                            domain_id = None

                        if domain_id:
                            hass.data[DOMAIN][entry.entry_id]["itflow_domain_id"] = domain_id
                            # Store domain ID
                            new_data = dict(entry.data)
                            new_data["itflow_domain_id"] = domain_id
                            hass.config_entries.async_update_entry(entry, data=new_data)
                            _LOGGER.info("Created ITFlow domain: %s (ID: %s)", domain_name, domain_id)
            except Exception as err:
                _LOGGER.error("Failed to create/update ITFlow domain: %s", err, exc_info=True)

        # Create location ONLY once (never update after initial creation)
        # DISABLED: Users should manually create location using the create_location service if needed
        # stored_location_id = entry.data.get("itflow_location_id")
        # location_created = entry.data.get("location_created", False)

        if False:  # Disabled automatic location creation
            try:
                # Get location info from HA configuration
                location_name = f"{title} - Primary Location"

                # Build proper address from HA config
                # Extract city from location_name or use default
                location_city = hass.config.location_name or "Home"

                # Build address - try reverse geocoding first
                location_address = ""
                if hasattr(hass.config, 'latitude') and hasattr(hass.config, 'longitude'):
                    try:
                        # Try to get full address from coordinates
                        import json
                        url = f"https://nominatim.openstreetmap.org/reverse?format=json&lat={hass.config.latitude}&lon={hass.config.longitude}"
                        response = await hass.async_add_executor_job(
                            lambda: __import__('requests').get(url, headers={'User-Agent': 'HomeAssistant'}, timeout=10).text
                        )
                        data = json.loads(response)
                        if 'address' in data:
                            addr_parts = []
                            addr = data['address']
                            # Build readable address
                            if 'road' in addr:
                                addr_parts.append(addr['road'])
                            if 'house_number' in addr:
                                addr_parts[-1] = f"{addr['house_number']} {addr_parts[-1]}" if addr_parts else addr['house_number']
                            if 'city' in addr or 'town' in addr or 'village' in addr:
                                location_city = addr.get('city') or addr.get('town') or addr.get('village', location_city)
                            if 'state' in addr:
                                location_state = addr.get('state', location_state)
                            if 'country' in addr:
                                location_country = addr.get('country', location_country)

                            location_address = ', '.join(addr_parts) if addr_parts else f"{hass.config.latitude}, {hass.config.longitude}"
                        else:
                            location_address = f"{hass.config.latitude}, {hass.config.longitude}"
                    except:
                        # Fallback to coordinates
                        location_address = f"{hass.config.latitude}, {hass.config.longitude}"

                # Get timezone as state/province
                location_state = hass.config.time_zone.split('/')[-1].replace('_', ' ') if hass.config.time_zone else ""

                # Get country
                location_country = hass.config.country or ""

                # Get external IP if available
                try:
                    external_ip = await hass.async_add_executor_job(
                        lambda: __import__('requests').get('https://api.ipify.org', timeout=5).text
                    )
                    location_notes = f"HA Instance ID: {ha_instance_id}\nExternal IP: {external_ip}\nLocal IP: {local_ip}"
                except:
                    location_notes = f"HA Instance ID: {ha_instance_id}\nLocal IP: {local_ip}"

                location_response = await client.create_location(
                    location_name=location_name,
                    location_description=f"Primary Home Assistant location for {title}",
                    location_country=location_country,
                    location_address=location_address,
                    location_city=location_city,
                    location_state=location_state,
                    location_notes=location_notes,
                    location_primary="1"
                )

                if isinstance(location_response, dict) and location_response.get("success"):
                    response_data = location_response.get("data", {})
                    if isinstance(response_data, list) and len(response_data) > 0:
                        location_id = response_data[0].get("location_id") or response_data[0].get("insert_id")
                    elif isinstance(response_data, dict):
                        location_id = response_data.get("location_id") or response_data.get("insert_id")
                    else:
                        location_id = None

                    if location_id:
                        hass.data[DOMAIN][entry.entry_id]["itflow_location_id"] = location_id
                        # Store location ID and mark as created
                        new_data = dict(entry.data)
                        new_data["itflow_location_id"] = location_id
                        new_data["location_created"] = True
                        hass.config_entries.async_update_entry(entry, data=new_data)
                        _LOGGER.info("Created ITFlow location: %s (ID: %s)", location_name, location_id)
                else:
                    # Mark as attempted even if failed
                    new_data = dict(entry.data)
                    new_data["location_created"] = True
                    hass.config_entries.async_update_entry(entry, data=new_data)
            except Exception as err:
                _LOGGER.error("Failed to create ITFlow location: %s", err, exc_info=True)
                # Mark as attempted to prevent retry loops
                new_data = dict(entry.data)
                new_data["location_created"] = True
                hass.config_entries.async_update_entry(entry, data=new_data)

        # Create or get "HA Diagnostics" folder
        folder_id = entry.data.get("itflow_diagnostics_folder_id")
        if not folder_id:
            try:
                # Try to get existing folders first
                folders_response = await client.get_document_folders()
                if folders_response.get("success") and folders_response.get("data"):
                    folders = folders_response["data"]
                    # Look for existing "HA Diagnostics" folder
                    for folder in folders:
                        if folder.get("document_folder_name") == "HA Diagnostics":
                            folder_id = folder.get("document_folder_id")
                            break

                # Create folder if not found
                if not folder_id:
                    folder_response = await client.create_document_folder("HA Diagnostics")
                    if folder_response.get("success"):
                        response_data = folder_response.get("data", {})
                        if isinstance(response_data, list) and len(response_data) > 0:
                            folder_id = response_data[0].get("document_folder_id") or response_data[0].get("insert_id")
                        elif isinstance(response_data, dict):
                            folder_id = response_data.get("document_folder_id") or response_data.get("insert_id")

                        if folder_id:
                            # Store folder ID
                            new_data = dict(entry.data)
                            new_data["itflow_diagnostics_folder_id"] = folder_id
                            hass.config_entries.async_update_entry(entry, data=new_data)
                            _LOGGER.info("Created HA Diagnostics folder (ID: %s)", folder_id)
            except Exception as err:
                _LOGGER.warning("Could not create HA Diagnostics folder: %s", err)
                folder_id = None

        # DISABLED: Automatic document creation/update removed
        # Use services create_document and update_document instead
        if False:
            # Create or update separate documents if IDs are provided
            doc_config = {
                CONF_DOC_ID_GENERAL: ("get_system_info", f"{title} - General Info"),
                CONF_DOC_ID_AUTOMATIONS: ("get_automation_status", f"{title} - Automations"),
                CONF_DOC_ID_INTEGRATIONS: ("get_integrations_info", f"{title} - Integrations"),
                CONF_DOC_ID_BACKUP: ("get_backup_status", f"{title} - Backup Status"),
            }

            # Add Proxmox doc if Proxmox is enabled
            if data.get("proxmox_enabled", False):
                doc_config[CONF_DOC_ID_PROXMOX] = ("_get_proxmox_info", f"{title} - Proxmox Info")

        # Process each document type
        for conf_key, (method_name, doc_name) in ({}.items() if True else doc_config.items()):
            doc_id = entry.data.get(conf_key)

            # CRITICAL: Only proceed if this specific document ID is configured
            # Skip if no doc ID is set for this document type
            if not doc_id:
                _LOGGER.debug("Skipping %s - no document ID configured", conf_key)
                continue

            try:
                # Generate content using the appropriate method
                if method_name == "_get_proxmox_info":
                    document_content = await client._get_proxmox_info(hass)
                    if not document_content:
                        continue  # Skip if no Proxmox info available
                else:
                    method = getattr(client, method_name)
                    document_content = await method(hass)

                # Update existing document (we know doc_id exists because of check above)
                _LOGGER.info("Updating ONLY document ID %s (%s) - will NOT touch other docs", doc_id, doc_name)
                await client.update_document(
                    document_id=doc_id,
                    document_name=doc_name,
                    document_content=document_content,
                    document_description="Auto-updated by AutoH integration"
                )
                _LOGGER.info("‚úÖ Successfully updated ONLY document ID: %s", doc_id)
                # Store the doc ID in runtime data
                hass.data[DOMAIN][entry.entry_id][conf_key] = doc_id
                # Update last document update timestamp
                from datetime import datetime, timezone
                hass.data[DOMAIN][entry.entry_id]["last_document_update"] = datetime.now(timezone.utc)

                # Trigger update for the AutoH Report Last Updated sensor
                try:
                    entity_id = f"sensor.{entry.title.lower().replace(' ', '_')}_autoh_report_last_updated"
                    _LOGGER.debug("Triggering update for sensor: %s", entity_id)
                    await hass.helpers.entity_component.async_update_entity(entity_id)
                except Exception as update_err:
                    _LOGGER.debug("Could not trigger sensor update: %s", update_err)

            except Exception as err:
                _LOGGER.error("Failed to update document %s: %s", conf_key, err, exc_info=True)

        # Get owner info
        owner_name = "Unknown"
        owner_password = "Set during HA setup"
        try:
            owner_entity = person.async_get_owner(hass)
            if owner_entity:
                owner_name = owner_entity.name or "Unknown"
        except Exception:
            pass

        # Create initial setup ticket on first setup (not already created)
        startup_ticket_created = entry.data.get("startup_ticket_created", False)

        if not startup_ticket_created:
            try:
                # Get public URL safely
                try:
                    public_url_display = public_url or get_url(hass, allow_internal=False)
                except Exception:
                    public_url_display = "Not configured"

                ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #4CAF50; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">‚ú® New Home Assistant Instance Detected</h2>

<div style="background-color: #e8f5e9; border-left: 4px solid #4CAF50; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #2e7d32;">üìã Instance Details</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Name:</td>
            <td style="padding: 8px;">{title}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Local IP:</td>
            <td style="padding: 8px;">{local_ip}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Public URL:</td>
            <td style="padding: 8px;">{public_url_display}</td>
        </tr>
    </table>
</div>

<div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #856404;">üîê Access Credentials</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Username:</td>
            <td style="padding: 8px;">{owner_name}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Password:</td>
            <td style="padding: 8px;">{owner_password}</td>
        </tr>
    </table>
</div>

<div style="background-color: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #1565c0;">üìù Next Steps</h3>
    <ol style="margin: 0; padding-left: 20px;">
        <li style="padding: 4px 0;">Complete the Home Assistant setup process</li>
        <li style="padding: 4px 0;">Verify the installation is working correctly</li>
        <li style="padding: 4px 0;">Configure integrations and automations as needed</li>
    </ol>
</div>
{get_ticket_footer(hass, entry)}
</div>"""
                await client.create_ticket(
                    subject="‚ú® New HA Instance Detected",
                    details=ticket_details,
                    priority="Medium",
                    contact_id=hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id"),
                    asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                    category_id=41,
                    status="7",
                    assigned_to=4
                )
                # Mark as created
                new_data = dict(entry.data)
                new_data["startup_ticket_created"] = True
                hass.config_entries.async_update_entry(entry, data=new_data)
                _LOGGER.info("Created initial ITFlow setup ticket")
            except Exception as err:
                _LOGGER.error("Failed to create ITFlow setup ticket: %s", err, exc_info=True)
        elif startup_ticket_created:
            _LOGGER.info("Startup ticket already created, skipping")

        # Set up error log monitoring if enabled
        if data.get(CONF_ALERT_ON_ERRORS, False):
            setup_error_monitoring(hass, entry)

        # Set up periodic updates (every 5 hours)
        setup_periodic_updates(hass, entry)

        # Set up system monitoring
        setup_system_monitoring(hass, entry)

        # Set up scheduled health reports if enabled
        if data.get(CONF_HEALTH_REPORT_ENABLED, False):
            setup_health_reports(hass, entry)

        # Create startup ticket if enabled and not in tickets_only mode
        if data.get(CONF_CREATE_STARTUP_TICKET, False) and data.get(CONF_INTEGRATION_MODE) != INTEGRATION_MODE_TICKETS_ONLY:
            try:
                from datetime import datetime
                startup_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

                ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #2196F3; border-bottom: 2px solid #2196F3; padding-bottom: 10px;">üîÑ Home Assistant Restarted</h2>

<div style="background-color: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #1565c0;">‚è∞ Restart Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Restart Time:</td>
            <td style="padding: 8px;">{startup_time}</td>
        </tr>
    </table>
</div>

<div style="background-color: #f5f5f5; border-left: 4px solid #757575; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #424242;">üíª System Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Instance:</td>
            <td style="padding: 8px;">{title}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Version:</td>
            <td style="padding: 8px;">{ha_version}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Local IP:</td>
            <td style="padding: 8px;">{local_ip}</td>
        </tr>"""

                if public_url:
                    ticket_details += f"""
        <tr>
            <td style="padding: 8px; font-weight: bold;">Public URL:</td>
            <td style="padding: 8px;">{public_url}</td>
        </tr>"""

                ticket_details += f"""
    </table>
</div>

<div style="background-color: #e8f5e9; border-left: 4px solid #4CAF50; padding: 15px; margin: 15px 0;">
    <p style="margin: 0; color: #2e7d32;">‚úÖ The system is now operational and all services have been restored.</p>
</div>
{get_ticket_footer(hass, entry)}
</div>"""

                response = await client.create_ticket(
                    subject=f"üîÑ Home Assistant Restarted - {title}",
                    details=ticket_details,
                    priority="Low",
                    contact_id=hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id"),
                    asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                    category_id=41,
                    status="7",
                    assigned_to=4
                )

                if response.get("success"):
                    _LOGGER.info("Created startup ticket in ITFlow")
                else:
                    _LOGGER.error("Failed to create startup ticket: %s", response.get("message"))
            except Exception as err:
                _LOGGER.error("Error creating startup ticket: %s", err, exc_info=True)

        # Send initial health report if this is first installation
        if entry.data.get("first_installation"):
            try:
                _LOGGER.info("First installation detected - sending initial health report")
                import psutil

                # Get system information in executor
                def get_system_stats():
                    return {
                        'disk': psutil.disk_usage('/'),
                        'memory': psutil.virtual_memory(),
                        'cpu_percent': psutil.cpu_percent(interval=1)
                    }

                system_stats = await hass.async_add_executor_job(get_system_stats)
                disk = system_stats['disk']
                memory = system_stats['memory']
                cpu_percent = system_stats['cpu_percent']

                # Get entity counts
                entity_states = hass.states.async_all()
                total_entities = len(entity_states)

                # Count entities by domain
                domain_counts = {}
                for state in entity_states:
                    domain = state.entity_id.split('.')[0]
                    domain_counts[domain] = domain_counts.get(domain, 0) + 1

                # Get top 5 domains
                top_domains = sorted(domain_counts.items(), key=lambda x: x[1], reverse=True)[:5]

                # Create initial health report
                ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #4CAF50; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">‚úÖ OnOff Support Agent Installed Successfully!</h2>

<div style="background-color: #e8f5e9; border-left: 4px solid #4CAF50; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #2e7d32;">üìä Initial System Health Report</h3>
    <p>Your Home Assistant installation is now connected to OnOff Support Agent. Here's the initial system snapshot:</p>
</div>

<div style="background-color: #f5f5f5; border-left: 4px solid #757575; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #424242;">üíª System Resources</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">CPU Usage:</td>
            <td style="padding: 8px;">
                <div style="background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
                    <div style="background-color: {'#4CAF50' if cpu_percent < 70 else '#ff9800' if cpu_percent < 90 else '#f44336'}; color: white; padding: 4px 8px; width: {cpu_percent}%; text-align: center; min-width: 40px;">{cpu_percent}%</div>
                </div>
            </td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Memory Usage:</td>
            <td style="padding: 8px;">
                <div style="background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
                    <div style="background-color: {'#4CAF50' if memory.percent < 70 else '#ff9800' if memory.percent < 90 else '#f44336'}; color: white; padding: 4px 8px; width: {memory.percent}%; text-align: center; min-width: 40px;">{memory.percent}%</div>
                </div>
            </td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Disk Usage:</td>
            <td style="padding: 8px;">
                <div style="background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
                    <div style="background-color: {'#4CAF50' if disk.percent < 70 else '#ff9800' if disk.percent < 90 else '#f44336'}; color: white; padding: 4px 8px; width: {disk.percent}%; text-align: center; min-width: 40px;">{disk.percent}%</div>
                </div>
            </td>
        </tr>
    </table>
</div>

<div style="background-color: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #1565c0;">üè† Home Assistant Overview</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Total Entities:</td>
            <td style="padding: 8px;">{total_entities}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Version:</td>
            <td style="padding: 8px;">{ha_version}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Top 5 Domains:</td>
            <td style="padding: 8px;">"""

                for domain, count in top_domains:
                    ticket_details += f"<strong>{domain}:</strong> {count}&nbsp;&nbsp; "

                ticket_details += f"""</td>
        </tr>
    </table>
</div>

<div style="background-color: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #e65100;">üöÄ Next Steps</h3>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">
        <li>Your system is being monitored for issues</li>
        <li>Automatic alerts are {'enabled' if entry.data.get(CONF_ALERT_ON_ERRORS) else 'disabled'}</li>
        <li>Health reports will be sent {'daily' if entry.data.get(CONF_HEALTH_REPORT_FREQUENCY) == 'daily' else 'weekly' if entry.data.get(CONF_HEALTH_REPORT_ENABLED) else 'manually'}</li>
        <li>Use the custom dashboard cards to create tickets and view status</li>
    </ul>
</div>

{get_ticket_footer(hass, entry)}
</div>"""

                response = await client.create_ticket(
                    subject=f"‚úÖ OnOff Support Agent Installed - {title}",
                    details=ticket_details,
                    priority="Low",
                    contact_id=hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id"),
                    asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                    category_id=41,
                    status="7",
                    assigned_to=4
                )

                if response.get("success"):
                    _LOGGER.info("Sent initial health report ticket")
                    # Clear the first_installation flag
                    new_data = dict(entry.data)
                    new_data.pop("first_installation", None)
                    hass.config_entries.async_update_entry(entry, data=new_data)
                else:
                    _LOGGER.error("Failed to send initial health report: %s", response.get("message"))
            except Exception as err:
                _LOGGER.error("Error sending initial health report: %s", err, exc_info=True)

    except Exception as err:
        _LOGGER.error("Error setting up ITFlow: %s", err)


def setup_error_monitoring(hass: HomeAssistant, entry: ConfigEntry):
    """Set up error and warning monitoring for automatic ticket creation."""
    from datetime import datetime, timedelta

    # Track recent errors to avoid duplicates
    recent_errors = {}
    error_cooldown = timedelta(minutes=30)  # Don't create duplicate tickets within 30 minutes

    async def handle_system_log_event(event_data):
        """Listen for system_log events (ERROR, WARNING, and CRITICAL levels) and create tickets."""
        try:
            # Get event data
            level = event_data.data.get("level")
            message = event_data.data.get("message", [""])[0] if isinstance(event_data.data.get("message"), list) else event_data.data.get("message", "")
            timestamp = event_data.data.get("timestamp")
            logger_name = event_data.data.get("name", "Unknown")
            exception = event_data.data.get("exception", "")
            source = event_data.data.get("source", ["Unknown"])[0] if isinstance(event_data.data.get("source"), list) else event_data.data.get("source", "Unknown")

            # Only process ERROR, WARNING, and CRITICAL levels
            if level not in ["ERROR", "WARNING", "CRITICAL"]:
                return

            # Skip errors from this integration to avoid infinite loops
            if DOMAIN in logger_name:
                return

            # Create a hash of the message to detect duplicates
            import hashlib
            error_hash = hashlib.md5(f"{logger_name}:{message[:100]}".encode()).hexdigest()

            # Check if we've seen this error recently
            now = datetime.now()
            if error_hash in recent_errors:
                last_seen = recent_errors[error_hash]
                if now - last_seen < error_cooldown:
                    return  # Skip duplicate

            recent_errors[error_hash] = now

            # Clean up old entries
            expired_keys = [k for k, v in recent_errors.items() if now - v > error_cooldown]
            for k in expired_keys:
                del recent_errors[k]

            # Get client
            client = hass.data[DOMAIN][entry.entry_id].get("itflow_client")
            if not client:
                return

            # Format timestamp
            event_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

            # Determine severity based on level
            if level == "CRITICAL":
                severity_color = "#b71c1c"
                severity_bg = "#ffcdd2"
                severity_icon = "üî¥"
                priority = "High"
            elif level == "ERROR":
                severity_color = "#f44336"
                severity_bg = "#ffebee"
                severity_icon = "üü†"
                priority = "High"
            else:  # WARNING
                severity_color = "#ff9800"
                severity_bg = "#fff3e0"
                severity_icon = "‚ö†Ô∏è"
                priority = "Medium"

            # Create ticket with enhanced HTML formatting
            ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: {severity_color}; border-bottom: 2px solid {severity_color}; padding-bottom: 10px;">{severity_icon} System {level.title()} Detected</h2>

<div style="background-color: {severity_bg}; border-left: 4px solid {severity_color}; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #424242;">{severity_icon} {level.title()} Details</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Time:</td>
            <td style="padding: 8px;">{event_time}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Level:</td>
            <td style="padding: 8px;"><span style="background-color: {severity_color}; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{level}</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Logger:</td>
            <td style="padding: 8px;"><code style="background-color: #f5f5f5; padding: 4px 8px; border-radius: 3px;">{logger_name}</code></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Source:</td>
            <td style="padding: 8px;"><code style="background-color: #f5f5f5; padding: 4px 8px; border-radius: 3px;">{source}</code></td>
        </tr>
    </table>
</div>

<div style="background-color: #f5f5f5; border-left: 4px solid #757575; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #424242;">üìù Error Message</h3>
    <div style="background-color: #fff; padding: 12px; border-radius: 4px; font-family: monospace; font-size: 13px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;">
{message}
    </div>
</div>"""

            if exception:
                ticket_details += f"""
<div style="background-color: #ffebee; border-left: 4px solid #f44336; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #c62828;">üêõ Stack Trace</h3>
    <div style="background-color: #fff; padding: 12px; border-radius: 4px; font-family: monospace; font-size: 12px; overflow-x: auto; max-height: 300px; overflow-y: auto;">
        <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">{exception}</pre>
    </div>
</div>"""

            # Add timestamp details if available
            if timestamp:
                ticket_details += f"""
<div style="background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #2e7d32;">üïê Timestamp Information</h3>
    <p style="margin: 0; font-family: monospace; background-color: #fff; padding: 8px; border-radius: 4px;">{timestamp}</p>
</div>"""

            ticket_details += f"""
<div style="background-color: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #1565c0;">üí° Recommended Actions</h3>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">
        <li>Review the error message and stack trace above</li>
        <li>Check Home Assistant logs for additional context: <code>/config/home-assistant.log</code></li>
        <li>Verify affected integration or automation is working correctly</li>
        <li>Check for recent configuration changes that may have caused this</li>
        <li>Search for similar errors in Home Assistant forums and GitHub issues</li>
    </ul>
</div>
{get_ticket_footer(hass, entry)}
</div>"""

            await client.create_ticket(
                subject=f"{severity_icon} {level}: {logger_name} - {message[:50]}",
                details=ticket_details,
                priority=priority,
                contact_id=hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id"),
                asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                category_id=41,
                status="7",
                assigned_to=4
            )

            _LOGGER.info("Created ticket for system %s: %s - %s", level.lower(), logger_name, message[:50])

        except Exception as err:
            _LOGGER.error("Error in system log listener: %s", err, exc_info=True)

    # Listen to system_log_event
    hass.bus.async_listen("system_log_event", handle_system_log_event)
    _LOGGER.info("Error and warning monitoring enabled")


def setup_periodic_updates(hass: HomeAssistant, entry: ConfigEntry):
    """Set up periodic updates for asset and documents (every 5 minutes)."""
    # DISABLED: Automatic document updates removed - use services instead
    return

    import homeassistant.helpers.event as event
    from datetime import timedelta, datetime, timezone

    async def update_all_documents(now):
        """Update all documents with latest info every 5 minutes."""
        try:
            client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
            if not client:
                return

            title = entry.data.get(CONF_NAME, "On-Off ITFlow")
            data = entry.data

            # Define document configurations
            doc_config = {
                CONF_DOC_ID_GENERAL: ("get_system_info", f"{title} - General Info"),
                CONF_DOC_ID_AUTOMATIONS: ("get_automation_status", f"{title} - Automations"),
                CONF_DOC_ID_INTEGRATIONS: ("get_integrations_info", f"{title} - Integrations"),
                CONF_DOC_ID_BACKUP: ("get_backup_status", f"{title} - Backup Status"),
            }

            # Add Proxmox doc if Proxmox is enabled
            if data.get("proxmox_enabled", False):
                doc_config[CONF_DOC_ID_PROXMOX] = ("_get_proxmox_info", f"{title} - Proxmox Info")

            # Update each document
            for conf_key, (method_name, doc_name) in doc_config.items():
                doc_id = hass.data[DOMAIN][entry.entry_id].get(conf_key)

                # CRITICAL: Only update if this specific document ID exists
                if not doc_id:
                    _LOGGER.debug("Skipping periodic update for %s - no document ID configured", conf_key)
                    continue

                try:
                    # Generate content using the appropriate method
                    if method_name == "_get_proxmox_info":
                        document_content = await client._get_proxmox_info(hass)
                        if not document_content:
                            continue  # Skip if no Proxmox info available
                    else:
                        method = getattr(client, method_name)
                        document_content = await method(hass)

                    # Update ONLY this specific document
                    _LOGGER.debug("Periodic update: Updating ONLY document ID %s (%s)", doc_id, doc_name)
                    await client.update_document(
                        document_id=doc_id,
                        document_name=doc_name,
                        document_content=document_content,
                        document_description=f"Auto-updated - {now.strftime('%Y-%m-%d %H:%M:%S')}"
                    )
                    _LOGGER.debug("Periodic update: Successfully updated ONLY document ID %s (%s)", doc_id, doc_name)
                    # Update last document update timestamp
                    if DOMAIN in hass.data and entry.entry_id in hass.data[DOMAIN]:
                        from datetime import timezone
                        hass.data[DOMAIN][entry.entry_id]["last_document_update"] = datetime.now(timezone.utc)

                        # Trigger update for the AutoH Report Last Updated sensor
                        try:
                            entity_id = f"sensor.{entry.title.lower().replace(' ', '_')}_autoh_report_last_updated"
                            _LOGGER.debug("Triggering update for sensor: %s", entity_id)
                            await hass.helpers.entity_component.async_update_entity(entity_id)
                        except Exception as update_err:
                            _LOGGER.debug("Could not trigger sensor update: %s", update_err)
                except Exception as doc_err:
                    _LOGGER.error("Error updating document %s (ID: %s): %s", conf_key, doc_id, doc_err)

        except Exception as err:
            _LOGGER.error("Error in periodic document update: %s", err)

    async def update_asset(now):
        """Update asset info every 5 hours."""
        try:
            client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
            if not client:
                return

            # Get latest info
            local_ip = str(hass.config.api.local_ip) if hass.config.api else "Unknown"
            ha_instance_id = hass.data.get("core.uuid", "Unknown")
            title = entry.data.get(CONF_NAME, "On-Off ITFlow")
            public_url = entry.data.get(CONF_PUBLIC_URL, "")

            # Update asset
            asset_id = hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id")
            if asset_id:
                asset_notes = f"HA Instance ID: {ha_instance_id}\n"
                asset_notes += f"Public URL: {public_url}\n" if public_url else ""
                asset_notes += f"Home Assistant installation: {title}\n"
                asset_notes += f"Last updated: {now.strftime('%Y-%m-%d %H:%M:%S')}"

                await client.update_asset(
                    asset_id=asset_id,
                    asset_ip=local_ip,
                    asset_notes=asset_notes
                )
                _LOGGER.info("Periodic update: Updated asset ID %s", asset_id)

        except Exception as err:
            _LOGGER.error("Error in asset update: %s", err)

    # Update all documents every 5 minutes
    event.async_track_time_interval(hass, update_all_documents, timedelta(minutes=5))

    # Update asset every 5 hours
    event.async_track_time_interval(hass, update_asset, timedelta(hours=5))

    _LOGGER.info("Periodic updates scheduled: Documents every 5min, Asset every 5hrs")

    # Set up user login tracking
    async def user_login_listener(event_data):
        """Listen for user login events and update all documents."""
        try:
            from datetime import datetime
            # Update all documents when user logs in
            client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
            if not client:
                return

            title = entry.data.get(CONF_NAME, "On-Off ITFlow")
            data = entry.data

            # Define document configurations
            doc_config = {
                CONF_DOC_ID_GENERAL: ("get_system_info", f"{title} - General Info"),
                CONF_DOC_ID_AUTOMATIONS: ("get_automation_status", f"{title} - Automations"),
                CONF_DOC_ID_INTEGRATIONS: ("get_integrations_info", f"{title} - Integrations"),
                CONF_DOC_ID_BACKUP: ("get_backup_status", f"{title} - Backup Status"),
            }

            # Add Proxmox doc if Proxmox is enabled
            if data.get("proxmox_enabled", False):
                doc_config[CONF_DOC_ID_PROXMOX] = ("_get_proxmox_info", f"{title} - Proxmox Info")

            # Update each document
            for conf_key, (method_name, doc_name) in doc_config.items():
                doc_id = hass.data[DOMAIN][entry.entry_id].get(conf_key)

                if doc_id:
                    try:
                        # Generate content
                        if method_name == "_get_proxmox_info":
                            document_content = await client._get_proxmox_info(hass)
                            if not document_content:
                                continue
                        else:
                            method = getattr(client, method_name)
                            document_content = await method(hass)

                        # Update the document
                        await client.update_document(
                            document_id=doc_id,
                            document_name=doc_name,
                            document_content=document_content,
                            document_description=f"Updated on user login - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                        )
                    except Exception as doc_err:
                        _LOGGER.debug("Error updating document on user login: %s", doc_err)

            _LOGGER.info("Updated documents on user login event")

        except Exception as err:
            _LOGGER.debug("Error in user login listener: %s", err)

    # Subscribe to user login events
    hass.bus.async_listen("homeassistant.auth.login", user_login_listener)


def setup_system_monitoring(hass: HomeAssistant, entry: ConfigEntry):
    """Set up system monitoring for resource alerts."""
    import homeassistant.helpers.event as event
    from datetime import timedelta
    import psutil

    # Track last alert times and ticket IDs to avoid spam and auto-close
    last_alerts = {
        "disk": None,
        "memory": None,
        "cpu": None,
        "ip": None,
    }

    # Track ticket IDs for auto-closing
    alert_ticket_ids = {
        "disk": None,
        "memory": None,
        "cpu": None,
        "ping_8888": None,
    }

    # Track last known IP
    last_ip = {"value": None}

    async def check_system_resources(now):
        """Check system resources and create tickets if thresholds exceeded."""
        try:
            client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
            if not client:
                return

            data = entry.data
            asset_id = hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id")
            contact_id = hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id")

            # Check disk usage
            if data.get(CONF_MONITOR_DISK, True):
                disk = psutil.disk_usage('/')
                disk_threshold = data.get(CONF_DISK_THRESHOLD, 90)
                if disk.percent >= disk_threshold:
                    # Only alert once per hour
                    if last_alerts["disk"] is None or (now - last_alerts["disk"]).total_seconds() > 3600:
                        from datetime import datetime
                        alert_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

                        response = await client.create_ticket(
                            subject=f"‚ö†Ô∏è Low Disk Space Alert - {disk.percent}% Full",
                            details=f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #f44336; border-bottom: 2px solid #f44336; padding-bottom: 10px;">‚ö†Ô∏è Critical: Low Disk Space Alert</h2>

<div style="background-color: #ffebee; border-left: 4px solid #f44336; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #c62828;">üî¥ Alert Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Alert Time:</td>
            <td style="padding: 8px;">{alert_time}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Current Usage:</td>
            <td style="padding: 8px;"><span style="background-color: #f44336; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{disk.percent}%</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Threshold:</td>
            <td style="padding: 8px;">{disk_threshold}%</td>
        </tr>
    </table>
</div>

<div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #856404;">üíæ Disk Usage Details</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Used Space:</td>
            <td style="padding: 8px;">{disk.used / (1024**3):.2f} GB</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Free Space:</td>
            <td style="padding: 8px;">{disk.free / (1024**3):.2f} GB</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Total Space:</td>
            <td style="padding: 8px;">{disk.total / (1024**3):.2f} GB</td>
        </tr>
    </table>
</div>

<div style="background-color: #ffcdd2; border-left: 4px solid #d32f2f; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #b71c1c;">‚ö° Action Required</h3>
    <p style="margin: 0; font-weight: bold;">Please free up disk space immediately to prevent system issues:</p>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">
        <li>Remove old backups or snapshots</li>
        <li>Clear log files if necessary</li>
        <li>Check for large files consuming space</li>
    </ul>
</div>
{get_ticket_footer(hass, entry)}
</div>""",
                            priority="High",
                            contact_id=contact_id,
                            asset_id=asset_id,
                            category_id=41,
                            status="7",
                            assigned_to=4
                        )
                        last_alerts["disk"] = now
                        # Store ticket ID for auto-closing
                        if response.get("success") and response.get("ticket_id"):
                            alert_ticket_ids["disk"] = response["ticket_id"]
                        _LOGGER.warning("Created ticket for low disk space: %s%%", disk.percent)
                elif alert_ticket_ids["disk"]:
                    # Disk usage is now below threshold, auto-close the ticket
                    await client.update_ticket(alert_ticket_ids["disk"], status="Resolved")
                    _LOGGER.info("Auto-closed disk alert ticket %s - disk usage now at %s%%", alert_ticket_ids["disk"], disk.percent)
                    alert_ticket_ids["disk"] = None
                    last_alerts["disk"] = None

            # Check memory usage
            if data.get(CONF_MONITOR_MEMORY, True):
                memory = psutil.virtual_memory()
                memory_threshold = data.get(CONF_MEMORY_THRESHOLD, 90)
                if memory.percent >= memory_threshold:
                    if last_alerts["memory"] is None or (now - last_alerts["memory"]).total_seconds() > 3600:
                        from datetime import datetime
                        alert_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

                        response = await client.create_ticket(
                            subject=f"‚ö†Ô∏è High Memory Usage Alert - {memory.percent}% Used",
                            details=f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #ff9800; border-bottom: 2px solid #ff9800; padding-bottom: 10px;">‚ö†Ô∏è High Memory Usage Alert</h2>

<div style="background-color: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #e65100;">üî∂ Alert Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Alert Time:</td>
            <td style="padding: 8px;">{alert_time}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Current Usage:</td>
            <td style="padding: 8px;"><span style="background-color: #ff9800; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{memory.percent}%</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Threshold:</td>
            <td style="padding: 8px;">{memory_threshold}%</td>
        </tr>
    </table>
</div>

<div style="background-color: #f5f5f5; border-left: 4px solid #757575; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #424242;">üß† Memory Usage Details</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Used Memory:</td>
            <td style="padding: 8px;">{memory.used / (1024**3):.2f} GB</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Available:</td>
            <td style="padding: 8px;">{memory.available / (1024**3):.2f} GB</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Total Memory:</td>
            <td style="padding: 8px;">{memory.total / (1024**3):.2f} GB</td>
        </tr>
    </table>
</div>

<div style="background-color: #ffe0b2; border-left: 4px solid #f57c00; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #e65100;">‚ö° Action Required</h3>
    <p style="margin: 0; font-weight: bold;">Investigate high memory usage:</p>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">
        <li>Check for memory-intensive integrations</li>
        <li>Review recent automation changes</li>
        <li>Consider restarting Home Assistant if issue persists</li>
    </ul>
</div>
{get_ticket_footer(hass, entry)}
</div>""",
                            priority="High",
                            contact_id=contact_id,
                            asset_id=asset_id,
                            category_id=41,
                            status="7",
                            assigned_to=4
                        )
                        last_alerts["memory"] = now
                        # Store ticket ID for auto-closing
                        if response.get("success") and response.get("ticket_id"):
                            alert_ticket_ids["memory"] = response["ticket_id"]
                        _LOGGER.warning("Created ticket for high memory usage: %s%%", memory.percent)
                elif alert_ticket_ids["memory"]:
                    # Memory usage is now below threshold, auto-close the ticket
                    await client.update_ticket(alert_ticket_ids["memory"], status="Resolved")
                    _LOGGER.info("Auto-closed memory alert ticket %s - memory usage now at %s%%", alert_ticket_ids["memory"], memory.percent)
                    alert_ticket_ids["memory"] = None
                    last_alerts["memory"] = None

            # Check CPU usage
            if data.get(CONF_MONITOR_CPU, True):
                cpu_percent = psutil.cpu_percent(interval=0)
                cpu_threshold = data.get(CONF_CPU_THRESHOLD, 90)
                if cpu_percent >= cpu_threshold:
                    if last_alerts["cpu"] is None or (now - last_alerts["cpu"]).total_seconds() > 3600:
                        from datetime import datetime
                        alert_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

                        response = await client.create_ticket(
                            subject=f"‚ö†Ô∏è High CPU Usage Alert - {cpu_percent}% Used",
                            details=f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #ff5722; border-bottom: 2px solid #ff5722; padding-bottom: 10px;">‚ö†Ô∏è High CPU Usage Alert</h2>

<div style="background-color: #fbe9e7; border-left: 4px solid #ff5722; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #d84315;">üî∂ Alert Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Alert Time:</td>
            <td style="padding: 8px;">{alert_time}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Current Usage:</td>
            <td style="padding: 8px;"><span style="background-color: #ff5722; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{cpu_percent}%</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Threshold:</td>
            <td style="padding: 8px;">{cpu_threshold}%</td>
        </tr>
    </table>
</div>

<div style="background-color: #ffccbc; border-left: 4px solid #ff5722; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #bf360c;">‚ö° Action Required</h3>
    <p style="margin: 0; font-weight: bold;">Investigate high CPU usage:</p>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">
        <li>Check for problematic automations running in loops</li>
        <li>Review recently added integrations</li>
        <li>Check system logs for errors</li>
        <li>Consider restarting if issue persists</li>
    </ul>
</div>
{get_ticket_footer(hass, entry)}
</div>""",
                            priority="High",
                            contact_id=contact_id,
                            asset_id=asset_id,
                            category_id=41,
                            status="7",
                            assigned_to=4
                        )
                        last_alerts["cpu"] = now
                        # Store ticket ID for auto-closing
                        if response.get("success") and response.get("ticket_id"):
                            alert_ticket_ids["cpu"] = response["ticket_id"]
                        _LOGGER.warning("Created ticket for high CPU usage: %s%%", cpu_percent)
                elif alert_ticket_ids["cpu"]:
                    # CPU usage is now below threshold, auto-close the ticket
                    await client.update_ticket(alert_ticket_ids["cpu"], status="Resolved")
                    _LOGGER.info("Auto-closed CPU alert ticket %s - CPU usage now at %s%%", alert_ticket_ids["cpu"], cpu_percent)
                    alert_ticket_ids["cpu"] = None
                    last_alerts["cpu"] = None

            # Check IP changes (both local and public)
            if data.get(CONF_MONITOR_IP, True):
                try:
                    # Check local IP
                    current_local_ip = str(hass.config.api.local_ip) if hass.config.api else None
                    if current_local_ip and last_ip.get("local") and current_local_ip != last_ip["local"]:
                        from datetime import datetime
                        change_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

                        await client.create_ticket(
                            subject=f"üîÑ Local IP Address Changed",
                            details=f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #2196F3; border-bottom: 2px solid #2196F3; padding-bottom: 10px;">üîÑ Local IP Address Changed</h2>

<div style="background-color: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #1565c0;">üì° Network Change Detected</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Change Time:</td>
            <td style="padding: 8px;">{change_time}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Previous IP:</td>
            <td style="padding: 8px;"><code style="background-color: #ffebee; padding: 4px 8px; border-radius: 3px;">{last_ip["local"]}</code></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">New IP:</td>
            <td style="padding: 8px;"><code style="background-color: #e8f5e9; padding: 4px 8px; border-radius: 3px;">{current_local_ip}</code></td>
        </tr>
    </table>
</div>

<div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #856404;">‚ö° Action Required</h3>
    <p style="margin: 0; font-weight: bold;">Please review and update network configurations:</p>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">
        <li>Update firewall rules with new IP address</li>
        <li>Adjust port forwarding configurations if needed</li>
        <li>Update DNS records if applicable</li>
        <li>Verify remote access still works</li>
    </ul>
</div>
{get_ticket_footer(hass, entry)}
</div>""",
                            priority="Medium",
                            contact_id=contact_id,
                            asset_id=asset_id,
                            category_id=41,
                            status="7",
                            assigned_to=4
                        )
                        _LOGGER.info("Created ticket for local IP change: %s -> %s", last_ip["local"], current_local_ip)
                    last_ip["local"] = current_local_ip

                    # Check public IP
                    try:
                        public_ip = await hass.async_add_executor_job(
                            lambda: __import__('requests').get('https://api.ipify.org', timeout=5).text
                        )
                        if last_ip.get("public") and public_ip != last_ip["public"]:
                            from datetime import datetime
                            change_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

                            await client.create_ticket(
                                subject=f"üåê Public IP Address Changed",
                                details=f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #673AB7; border-bottom: 2px solid #673AB7; padding-bottom: 10px;">üåê Public IP Address Changed</h2>

<div style="background-color: #ede7f6; border-left: 4px solid #673AB7; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #4527A0;">üåç Internet Connection Change Detected</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Change Time:</td>
            <td style="padding: 8px;">{change_time}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Previous IP:</td>
            <td style="padding: 8px;"><code style="background-color: #ffebee; padding: 4px 8px; border-radius: 3px;">{last_ip["public"]}</code></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">New IP:</td>
            <td style="padding: 8px;"><code style="background-color: #e8f5e9; padding: 4px 8px; border-radius: 3px;">{public_ip}</code></td>
        </tr>
    </table>
</div>

<div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #856404;">‚ö° Action Required</h3>
    <p style="margin: 0; font-weight: bold;">Please review and update external access configurations:</p>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">
        <li>Update DNS A records with new IP address</li>
        <li>Verify external access URL still works</li>
        <li>Update any third-party service configurations</li>
        <li>Check remote monitoring services</li>
    </ul>
</div>
{get_ticket_footer(hass, entry)}
</div>""",
                                priority="Medium",
                                contact_id=contact_id,
                                asset_id=asset_id,
                                category_id=41,
                                status="7",
                                assigned_to=4
                            )
                            _LOGGER.info("Created ticket for public IP change: %s -> %s", last_ip["public"], public_ip)
                        last_ip["public"] = public_ip
                    except:
                        pass

                except Exception as err:
                    _LOGGER.debug("Error checking IP: %s", err)

            # Check ping to 8.8.8.8
            try:
                import subprocess
                ping_result = await hass.async_add_executor_job(
                    lambda: subprocess.run(['ping', '-c', '1', '-W', '2', '8.8.8.8'],
                                         capture_output=True, text=True)
                )
                ping_success = ping_result.returncode == 0

                if not ping_success and last_alerts.get("ping_8888") is None:
                    response = await client.create_ticket(
                        subject=f"üî¥ Internet Connectivity Lost - Ping to 8.8.8.8 Failed",
                        details=f"""Unable to ping Google DNS (8.8.8.8).

**Status:** Connection Failed
**Time:** {now.strftime('%Y-%m-%d %H:%M:%S')}

This may indicate internet connectivity issues.

**Action Required:** Check network connection and router.
""",
                        priority="High",
                        contact_id=contact_id,
                        asset_id=asset_id,
                        category_id=41,
                        status="7",
                        assigned_to=4
                    )
                    last_alerts["ping_8888"] = now
                    # Store ticket ID for auto-closing
                    if response.get("success") and response.get("ticket_id"):
                        alert_ticket_ids["ping_8888"] = response["ticket_id"]
                    _LOGGER.warning("Created ticket for ping failure to 8.8.8.8")
                elif ping_success and alert_ticket_ids.get("ping_8888"):
                    # Ping recovered, auto-close the ticket
                    await client.update_ticket(alert_ticket_ids["ping_8888"], status="Resolved")
                    _LOGGER.info("Auto-closed ping alert ticket %s - connectivity restored", alert_ticket_ids["ping_8888"])
                    alert_ticket_ids["ping_8888"] = None
                    last_alerts["ping_8888"] = None

            except Exception as err:
                _LOGGER.debug("Error checking ping: %s", err)

        except Exception as err:
            _LOGGER.error("Error in system monitoring: %s", err)

    # Check every 5 minutes
    event.async_track_time_interval(hass, check_system_resources, timedelta(minutes=5))

    # Create ticket on HA restart
    async def ha_started_listener(event_data):
        """Create ticket when HA starts."""
        try:
            client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
            if not client:
                return

            asset_id = hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id")
            contact_id = hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id")

            # Get uptime
            try:
                import psutil
                import time
                boot_time = psutil.boot_time()
                uptime_seconds = time.time() - boot_time
                uptime_days = int(uptime_seconds // 86400)
                uptime_hours = int((uptime_seconds % 86400) // 3600)
                uptime_minutes = int((uptime_seconds % 3600) // 60)
                uptime_str = f"{uptime_days}d {uptime_hours}h {uptime_minutes}m"
            except:
                uptime_str = "Unknown"

            # Get HA version safely
            try:
                ha_version = hass.data.get('homeassistant', {}).get('version', 'Unknown')
                if ha_version == 'Unknown':
                    from homeassistant.const import __version__
                    ha_version = __version__
            except:
                ha_version = "Unknown"

            await client.create_ticket(
                subject=f"‚úÖ Home Assistant Restarted",
                details=f"""Home Assistant server has restarted and is back online.

**Restart Time:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Uptime Since Boot:** {uptime_str}
**Version:** {ha_version}

The system is now operational.
""",
                priority="Low",
                contact_id=contact_id,
                asset_id=asset_id,
                category_id=41,
                status="7",
                assigned_to=4
            )
            _LOGGER.info("Created ticket for HA restart")

            # Wait 45 seconds before updating documents to allow HA to fully initialize
            import asyncio
            _LOGGER.info("Waiting 45 seconds before updating documents after restart...")
            await asyncio.sleep(45)

            # Update all documents after restart
            _LOGGER.info("Updating all documents after HA restart")
            title = entry.data.get(CONF_NAME, "On-Off ITFlow")
            data = entry.data

            # Define document configurations
            doc_config = {
                CONF_DOC_ID_GENERAL: ("get_system_info", f"{title} - General Info"),
                CONF_DOC_ID_AUTOMATIONS: ("get_automation_status", f"{title} - Automations"),
                CONF_DOC_ID_INTEGRATIONS: ("get_integrations_info", f"{title} - Integrations"),
                CONF_DOC_ID_BACKUP: ("get_backup_status", f"{title} - Backup Status"),
            }

            # Add Proxmox doc if Proxmox is enabled
            if data.get("proxmox_enabled", False):
                doc_config[CONF_DOC_ID_PROXMOX] = ("_get_proxmox_info", f"{title} - Proxmox Info")

            # Update each document
            for conf_key, (method_name, doc_name) in doc_config.items():
                doc_id = hass.data[DOMAIN][entry.entry_id].get(conf_key)

                if doc_id:
                    try:
                        # Generate content
                        if method_name == "_get_proxmox_info":
                            document_content = await client._get_proxmox_info(hass)
                            if not document_content:
                                continue
                        else:
                            method = getattr(client, method_name)
                            document_content = await method(hass)

                        # Update the document
                        await client.update_document(
                            document_id=doc_id,
                            document_name=doc_name,
                            document_content=document_content,
                            document_description=f"Auto-updated after HA restart - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                        )
                        _LOGGER.info("Updated document ID %s after restart", doc_id)
                    except Exception as doc_err:
                        _LOGGER.error("Failed to update document %s after restart: %s", conf_key, doc_err)

        except Exception as err:
            _LOGGER.debug("Error in HA start listener: %s", err)

    # Listen for HA start event
    hass.bus.async_listen("homeassistant_start", ha_started_listener)

    # Set up alert listeners if enabled
    if entry.data.get(CONF_ALERT_ON_AUTOMATION_FAILURE):
        async def automation_failure_listener(event):
            """Listen for automation failures and create tickets."""
            try:
                automation_entity_id = event.data.get("entity_id", "Unknown")
                error_message = event.data.get("message", "Automation failed")

                client = hass.data[DOMAIN][entry.entry_id].get("itflow_client")
                if client:
                    ticket_subject = f"‚ö†Ô∏è Automation Failed: {automation_entity_id}"
                    ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #d32f2f; border-bottom: 2px solid #d32f2f; padding-bottom: 10px;">Automation Failure Detected</h2>

<div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Alert Details</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Entity ID:</td>
            <td style="padding: 8px;"><code>{automation_entity_id}</code></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Error:</td>
            <td style="padding: 8px; color: #d32f2f;"><strong>{error_message}</strong></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Time:</td>
            <td style="padding: 8px;">{datetime.now().strftime('%m/%d/%Y at %I:%M %p')}</td>
        </tr>
    </table>
</div>

<div style="background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0;">Event Data</h3>
    <pre style="background-color: #fff; padding: 10px; border-radius: 4px; overflow-x: auto;">{event.data}</pre>
</div>

<p style="color: #666; font-size: 12px; margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd;">
    ü§ñ This ticket was automatically generated by On-Off ITFlow integration
</p>
</div>"""
                    await client.create_ticket(
                        subject=ticket_subject,
                        details=ticket_details,
                        priority="Medium",
                        contact_id=hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id"),
                        asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                        category_id=41,
                        status="7",
                        assigned_to=4
                    )
                    _LOGGER.info("Created ticket for automation failure: %s", automation_entity_id)
            except Exception as err:
                _LOGGER.error("Error creating ticket for automation failure: %s", err)

        hass.bus.async_listen("automation_triggered", automation_failure_listener)
        _LOGGER.info("Automation failure alerts enabled")

    if entry.data.get(CONF_ALERT_ON_ERROR_LOGS):
        async def error_log_listener(event):
            """Listen for warning, error, and critical logs and create tickets."""
            try:
                level = event.data.get("level", "")
                if level in ["WARNING", "ERROR", "CRITICAL"]:
                    message = event.data.get("message", "Unknown error")
                    logger_name = event.data.get("name", "Unknown")

                    # Skip errors from this integration to avoid infinite loops
                    if DOMAIN in logger_name:
                        return

                    client = hass.data[DOMAIN][entry.entry_id].get("itflow_client")
                    if client:
                        # Set colors, icons, and priorities based on log level
                        if level == "CRITICAL":
                            level_color = "#d32f2f"
                            level_icon = "üî¥"
                            priority = "High"
                        elif level == "ERROR":
                            level_color = "#f57c00"
                            level_icon = "üü†"
                            priority = "High"
                        else:  # WARNING
                            level_color = "#ff9800"
                            level_icon = "‚ö†Ô∏è"
                            priority = "Medium"

                        ticket_subject = f"{level_icon} HA {level}: {logger_name}"
                        ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: {level_color}; border-bottom: 2px solid {level_color}; padding-bottom: 10px;">Error Log Entry Detected</h2>

<div style="background-color: #ffebee; border-left: 4px solid {level_color}; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #c62828;">{level_icon} Error Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Logger:</td>
            <td style="padding: 8px;"><code>{logger_name}</code></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Level:</td>
            <td style="padding: 8px;"><span style="background-color: {level_color}; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{level}</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Time:</td>
            <td style="padding: 8px;">{datetime.now().strftime('%m/%d/%Y at %I:%M %p')}</td>
        </tr>
    </table>
</div>

<div style="background-color: #fff; border: 2px solid {level_color}; border-radius: 4px; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: {level_color};">Error Message</h3>
    <p style="font-family: monospace; background-color: #f5f5f5; padding: 12px; border-radius: 4px; margin: 0;">{message}</p>
</div>

<details style="background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin: 15px 0;">
    <summary style="cursor: pointer; font-weight: bold; color: #666;">Full Event Data</summary>
    <pre style="background-color: #fff; padding: 10px; border-radius: 4px; margin-top: 10px; overflow-x: auto;">{event.data}</pre>
</details>

<p style="color: #666; font-size: 12px; margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd;">
    ü§ñ This ticket was automatically generated by On-Off ITFlow integration
</p>
</div>"""
                        await client.create_ticket(
                            subject=ticket_subject,
                            details=ticket_details,
                            priority=priority,
                            contact_id=hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id"),
                            asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                            category_id=41,
                            status="7",
                            assigned_to=4
                        )
                        _LOGGER.info("Created ticket for %s log: %s", level.lower(), logger_name)
            except Exception as err:
                _LOGGER.error("Error creating ticket for error log: %s", err)

        hass.bus.async_listen("system_log_event", error_log_listener)
        _LOGGER.info("Error log alerts enabled")

    if entry.data.get(CONF_ALERT_ON_NEW_UPDATE):
        # Track version sensor for updates
        async def version_check_listener(event):
            """Check for new HA updates and create tickets."""
            try:
                entity_id = event.data.get("entity_id", "")
                if "ha_version_latest" in entity_id:
                    new_state = event.data.get("new_state")
                    old_state = event.data.get("old_state")

                    if new_state and old_state and new_state.state != old_state.state:
                        latest_version = new_state.state

                        # Check if ticket was already created for this version
                        ticket_created_for = new_state.attributes.get("ticket_created_for_version")
                        if ticket_created_for == latest_version:
                            _LOGGER.debug("Ticket already created for version %s, skipping", latest_version)
                            return

                        # Get installed version
                        from homeassistant.const import __version__
                        installed_version = __version__

                        if latest_version != installed_version and latest_version != "Unknown":
                            client = hass.data[DOMAIN][entry.entry_id].get("itflow_client")
                            if client:
                                release_url = new_state.attributes.get("release_url", "https://github.com/home-assistant/core/releases")
                                release_date = new_state.attributes.get("release_date_formatted", "Unknown")
                                release_summary = new_state.attributes.get("release_summary", "")

                                ticket_subject = f"üîî New Home Assistant Update Available: {latest_version}"
                                ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #03a9f4; border-bottom: 2px solid #03a9f4; padding-bottom: 10px;">üéâ New Home Assistant Update Available</h2>

<div style="background-color: #e3f2fd; border-left: 4px solid #03a9f4; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #01579b;">üì¶ Version Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 180px;">Current Version:</td>
            <td style="padding: 8px;"><span style="background-color: #fff; padding: 4px 12px; border-radius: 4px; border: 1px solid #ddd;">{installed_version}</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">New Version:</td>
            <td style="padding: 8px;"><span style="background-color: #4caf50; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{latest_version}</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Release Date:</td>
            <td style="padding: 8px;">{release_date}</td>
        </tr>
    </table>
</div>

<div style="background-color: #fff; border: 1px solid #03a9f4; border-radius: 4px; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #03a9f4;">üìù Release Notes</h3>
    <div style="padding: 10px; background-color: #f5f5f5; border-radius: 4px;">
        {release_summary if release_summary else "No release notes available"}
    </div>
</div>

<div style="background-color: #fff9c4; border-left: 4px solid #fbc02d; padding: 15px; margin: 15px 0;">
    <p style="margin: 0;"><strong>üìÖ Action Required:</strong> Please review and schedule the update at your earliest convenience.</p>
</div>

<p style="text-align: center; margin: 20px 0;">
    <a href="{release_url}" style="display: inline-block; background-color: #03a9f4; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; font-weight: bold;">View Full Release Info</a>
</p>

<p style="color: #666; font-size: 12px; margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd;">
    ü§ñ This ticket was automatically generated by On-Off ITFlow integration
</p>
</div>"""
                                await client.create_ticket(
                                    subject=ticket_subject,
                                    details=ticket_details,
                                    priority="Low",
                                    contact_id=hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id"),
                                    asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                                    category_id=41,
                                    status="7",
                                    assigned_to=4
                                )
                                _LOGGER.info("Created ticket for new HA update: %s", latest_version)

                                # Mark that we created a ticket for this version
                                # Find and update the sensor
                                for sensor_entity_id in hass.states.async_entity_ids('sensor'):
                                    if 'ha_version_latest' in sensor_entity_id:
                                        # Get the sensor entity from the entity registry
                                        from homeassistant.helpers import entity_registry as er
                                        ent_reg = er.async_get(hass)
                                        entity_entry = ent_reg.async_get(sensor_entity_id)
                                        if entity_entry:
                                            # Find the sensor instance and call mark_ticket_created
                                            platform = hass.data.get("sensor")
                                            if platform and hasattr(platform, "entities"):
                                                for entity in platform.entities:
                                                    if entity.entity_id == sensor_entity_id:
                                                        if hasattr(entity, 'mark_ticket_created'):
                                                            entity.mark_ticket_created(latest_version)
                                                        break
                                        break
            except Exception as err:
                _LOGGER.error("Error creating ticket for new update: %s", err)

        hass.bus.async_listen("state_changed", version_check_listener)
        _LOGGER.info("New update alerts enabled")

    _LOGGER.info("System monitoring started - checking every 5 minutes")


def setup_health_reports(hass: HomeAssistant, entry: ConfigEntry):
    """Set up scheduled health reports."""
    import homeassistant.helpers.event as event
    from datetime import timedelta, datetime, time as dt_time

    data = entry.data
    frequency = data.get(CONF_HEALTH_REPORT_FREQUENCY, HEALTH_REPORT_WEEKLY)

    async def send_scheduled_health_report(now):
        """Send a scheduled health report."""
        try:
            # Call the health report service
            await hass.services.async_call(
                DOMAIN,
                "send_health_report",
                {},
                blocking=True
            )
            _LOGGER.info("Sent scheduled health report")
        except Exception as err:
            _LOGGER.error("Error sending scheduled health report: %s", err, exc_info=True)

    # Schedule based on frequency
    if frequency == HEALTH_REPORT_DAILY:
        # Daily at 8 AM
        event.async_track_time_change(
            hass,
            send_scheduled_health_report,
            hour=8,
            minute=0,
            second=0
        )
        _LOGGER.info("Health reports scheduled daily at 8:00 AM")
    else:  # HEALTH_REPORT_WEEKLY
        # Weekly on Monday at 8 AM
        async def check_and_send_weekly(now):
            """Check if it's Monday and send report."""
            if now.weekday() == 0:  # Monday
                await send_scheduled_health_report(now)

        event.async_track_time_change(
            hass,
            check_and_send_weekly,
            hour=8,
            minute=0,
            second=0
        )
        _LOGGER.info("Health reports scheduled weekly on Mondays at 8:00 AM")


# Panel functionality has been removed

# ProxMox monitoring has been removed


async def register_frontend_resources(hass: HomeAssistant):
    """Register frontend resources for custom cards."""
    from pathlib import Path
    import os

    # Get the integration directory
    integration_dir = Path(__file__).parent
    www_dir = integration_dir / "www"

    # List of card files to register
    card_files = [
        "onoff-open-tickets-card.js",
        "onoff-create-ticket-card.js",
        "onoff-create-asset-card.js",
        "onoff-health-report-card.js",
    ]

    # Copy files to www/community directory first (async)
    try:
        ha_www_dir = Path(hass.config.path("www"))
        community_dir = ha_www_dir / "community" / DOMAIN

        # Create directory if it doesn't exist
        await hass.async_add_executor_job(community_dir.mkdir, True, True)

        # Copy each card file using async executor
        import shutil
        for card_file in card_files:
            src = www_dir / card_file
            dst = community_dir / card_file
            if await hass.async_add_executor_job(src.exists):
                await hass.async_add_executor_job(shutil.copy2, src, dst)
            else:
                _LOGGER.debug(f"Source file not found: {src}")

    except Exception as err:
        _LOGGER.debug(f"Error copying frontend resources: {err}")

    # Register static path for the integration's www directory
    try:
        # Use async_register_static_paths for newer HA versions
        if hasattr(hass.http, 'async_register_static_paths'):
            await hass.http.async_register_static_paths([{
                "url": f"/local/community/{DOMAIN}",
                "path": str(www_dir),
            }])
        elif hasattr(hass.http, 'register_static_path'):
            hass.http.register_static_path(
                f"/local/community/{DOMAIN}",
                str(www_dir),
                cache_headers=False
            )
    except Exception as err:
        _LOGGER.debug(f"Error registering static path: {err}")

    # Check card files availability
    for card_file in card_files:
        card_path = www_dir / card_file
        if not card_path.exists():
            _LOGGER.debug(f"Card file not found: {card_path}")


def register_services(hass: HomeAssistant, entry: ConfigEntry):
    """Register ITFlow services."""

    async def handle_create_ticket(call: ServiceCall):
        """Handle the create_ticket service call."""
        client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
        if not client:
            _LOGGER.error("ITFlow client not initialized")
            return

        subject = call.data.get("ticket_subject")
        details = call.data.get("ticket_details")
        priority = call.data.get("ticket_priority", "Low")
        email = call.data.get("email")
        phone = call.data.get("phone")
        contact_id = call.data.get("contact_id")
        assigned_to = call.data.get("assigned_to")

        # Get logged-in user from context
        user_name = "Unknown User"
        if call.context.user_id:
            user = await hass.auth.async_get_user(call.context.user_id)
            if user:
                user_name = user.name or user_name

        # Format ticket with HTML if not already formatted
        if "<div" not in details and "<html" not in details.lower():
            # Not HTML, wrap in HTML with contact info
            details_html = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: #2196F3; border-bottom: 2px solid #2196F3; padding-bottom: 10px;">üìã Support Ticket</h2>

<div style="background-color: #f5f5f5; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #1565c0;">üìù Ticket Details</h3>
    <div style="background-color: #fff; padding: 12px; border-radius: 4px;">
        {details.replace(chr(10), '<br>')}
    </div>
</div>"""

            if email or phone or user_name != "Unknown User":
                details_html += f"""
<div style="background-color: #e3f2fd; border-left: 4px solid #03a9f4; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #01579b;">üë§ Contact Information</h3>
    <table style="width: 100%; border-collapse: collapse;">"""

                if user_name != "Unknown User":
                    details_html += f"""
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Submitted By:</td>
            <td style="padding: 8px;">{user_name}</td>
        </tr>"""

                if email:
                    details_html += f"""
        <tr>
            <td style="padding: 8px; font-weight: bold;">Email:</td>
            <td style="padding: 8px;"><a href="mailto:{email}">{email}</a></td>
        </tr>"""

                if phone:
                    details_html += f"""
        <tr>
            <td style="padding: 8px; font-weight: bold;">Phone:</td>
            <td style="padding: 8px;"><a href="tel:{phone}">{phone}</a></td>
        </tr>"""

                details_html += """
    </table>
</div>"""

            details_html += f"{get_ticket_footer(hass, entry)}</div>"
            details_with_info = details_html
        else:
            # Already HTML formatted, just add footer if not present
            if "ü§ñ This ticket was automatically generated" not in details:
                details_with_info = details.replace("</div>", f"{get_ticket_footer(hass, entry)}</div>", 1)
            else:
                details_with_info = details

        try:
            # Use provided contact_id or default to the "HA API" contact
            default_contact_id = hass.data[DOMAIN][entry.entry_id].get("itflow_contact_id")
            final_contact_id = contact_id if contact_id is not None else default_contact_id

            response = await client.create_ticket(
                subject=subject,
                details=details_with_info,
                priority=priority,
                contact_id=final_contact_id,
                asset_id=hass.data[DOMAIN][entry.entry_id].get("itflow_asset_id"),
                category="HA API",
                assigned_to=assigned_to
            )

            if response.get("success"):
                _LOGGER.info("Successfully created ITFlow ticket: %s", subject)
            else:
                _LOGGER.error("Failed to create ITFlow ticket: %s", response.get("message"))
        except Exception as err:
            _LOGGER.error("Error creating ITFlow ticket: %s", err)

    hass.services.async_register(
        DOMAIN,
        SERVICE_CREATE_TICKET,
        handle_create_ticket,
        schema=vol.Schema({
            vol.Required("ticket_subject"): cv.string,
            vol.Required("ticket_details"): cv.string,
            vol.Optional("ticket_priority", default="Low"): vol.In(["Low", "Medium", "High"]),
            vol.Optional("email"): cv.string,
            vol.Optional("phone"): cv.string,
            vol.Optional("contact_id"): cv.positive_int,
            vol.Optional("assigned_to"): cv.positive_int,
        })
    )

    async def handle_create_asset(call: ServiceCall):
        """Handle the create_asset service call."""
        client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
        if not client:
            _LOGGER.error("ITFlow client not initialized")
            return

        asset_name = call.data.get("asset_name")
        asset_type = call.data.get("asset_type")
        asset_make = call.data.get("asset_make")
        asset_model = call.data.get("asset_model")
        asset_serial = call.data.get("asset_serial")
        asset_os = call.data.get("asset_os")
        asset_ip = call.data.get("asset_ip")
        asset_mac = call.data.get("asset_mac")
        asset_purchase_date = call.data.get("asset_purchase")
        asset_warranty_expire = call.data.get("asset_warranty_expire")
        install_date = call.data.get("asset_install_date")
        asset_notes = call.data.get("asset_notes")

        try:
            response = await client.create_asset(
                asset_name=asset_name,
                asset_type=asset_type,
                asset_make=asset_make,
                asset_model=asset_model,
                asset_serial=asset_serial,
                asset_os=asset_os,
                asset_ip=asset_ip,
                asset_mac=asset_mac,
                asset_purchase_date=asset_purchase_date,
                asset_warranty_expire=asset_warranty_expire,
                install_date=install_date,
                asset_notes=asset_notes
            )

            if response.get("success"):
                _LOGGER.info("Successfully created ITFlow asset: %s", asset_name)
            else:
                _LOGGER.error("Failed to create ITFlow asset: %s", response.get("message"))
        except Exception as err:
            _LOGGER.error("Error creating ITFlow asset: %s", err)

    hass.services.async_register(
        DOMAIN,
        "create_asset",
        handle_create_asset,
        schema=vol.Schema({
            vol.Required("asset_name"): cv.string,
            vol.Required("asset_type"): cv.string,
            vol.Optional("asset_make"): cv.string,
            vol.Optional("asset_model"): cv.string,
            vol.Optional("asset_serial"): cv.string,
            vol.Optional("asset_os"): cv.string,
            vol.Optional("asset_ip"): cv.string,
            vol.Optional("asset_mac"): cv.string,
            vol.Optional("asset_purchase"): cv.string,
            vol.Optional("asset_warranty_expire"): cv.string,
            vol.Optional("asset_install_date"): cv.string,
            vol.Optional("asset_notes"): cv.string,
        })
    )

    async def handle_reply_to_ticket(call: ServiceCall):
        """Handle the reply_to_ticket service call."""
        from datetime import datetime

        _LOGGER.info("=== REPLY TO TICKET SERVICE CALLED ===")
        _LOGGER.info("Service call data: %s", call.data)

        client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
        if not client:
            _LOGGER.error("ITFlow client not initialized")
            raise Exception("ITFlow client not initialized")

        ticket_id = call.data.get("ticket_id")
        reply_text = call.data.get("reply_text")

        _LOGGER.info("Ticket ID: %s (type: %s)", ticket_id, type(ticket_id))
        _LOGGER.info("Reply Text: %s", reply_text)

        if not ticket_id:
            _LOGGER.error("No ticket_id provided")
            raise ValueError("ticket_id is required")

        if not reply_text:
            _LOGGER.error("No reply_text provided")
            raise ValueError("reply_text is required")

        # Get logged-in user from context
        user_name = "Unknown User"
        if call.context.user_id:
            user = await hass.auth.async_get_user(call.context.user_id)
            if user:
                user_name = user.name or user_name

        _LOGGER.info("Reply from user: %s", user_name)

        # Format reply with HTML and user info
        reply_html = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<div style="background-color: #e3f2fd; border-left: 4px solid #2196F3; padding: 12px; margin-bottom: 15px;">
    <strong>Reply from:</strong> {user_name}<br>
    <strong>Submitted via:</strong> Dashboard Card<br>
    <strong>Time:</strong> {datetime.now().strftime("%m/%d/%Y at %I:%M %p")}
</div>

<div style="background-color: #fff; padding: 12px; border-radius: 4px;">
    {reply_text.replace(chr(10), '<br>')}
</div>
</div>"""

        try:
            _LOGGER.info("Calling ITFlow API add_ticket_reply with ticket_id=%s", ticket_id)
            response = await client.add_ticket_reply(
                ticket_id=int(ticket_id),
                reply=reply_html
            )

            _LOGGER.info("ITFlow API response: %s", response)

            if response.get("success"):
                _LOGGER.info("‚úì Successfully added reply to ticket #%s", ticket_id)
            else:
                error_msg = response.get("message", "Unknown error")
                _LOGGER.error("‚úó Failed to add reply to ticket: %s", error_msg)
                raise Exception(f"ITFlow API error: {error_msg}")
        except Exception as err:
            _LOGGER.error("‚úó Error adding reply to ticket: %s", err, exc_info=True)
            raise

    hass.services.async_register(
        DOMAIN,
        "reply_to_ticket",
        handle_reply_to_ticket,
        schema=vol.Schema({
            vol.Required("ticket_id"): vol.Any(cv.positive_int, cv.string),
            vol.Required("reply_text"): cv.string,
        })
    )

    async def handle_send_health_report(call: ServiceCall):
        """Handle the send_health_report service call."""
        # Find the first active entry for this integration
        active_entry = None
        for entry_id, entry_data in hass.data[DOMAIN].items():
            if isinstance(entry_data, dict) and "itflow_client" in entry_data:
                active_entry = hass.config_entries.async_get_entry(entry_id)
                break

        if not active_entry:
            _LOGGER.error("No active OnOff Support Agent integration found")
            return

        client = hass.data[DOMAIN][active_entry.entry_id]["itflow_client"]
        if not client:
            _LOGGER.error("ITFlow client not initialized")
            return

        try:
            from datetime import datetime
            import psutil

            report_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")

            # Get system information - run blocking calls in executor
            def get_system_stats():
                return {
                    'disk': psutil.disk_usage('/'),
                    'memory': psutil.virtual_memory(),
                    'cpu_percent': psutil.cpu_percent(interval=1)
                }

            system_stats = await hass.async_add_executor_job(get_system_stats)
            disk = system_stats['disk']
            memory = system_stats['memory']
            cpu_percent = system_stats['cpu_percent']

            # Get HA information
            title = active_entry.data.get(CONF_NAME, "Home Assistant")
            local_ip = str(hass.config.api.local_ip) if hass.config.api else "Unknown"
            public_url = active_entry.data.get(CONF_PUBLIC_URL, "Not configured")

            # Get version from sensor.ha_version_installed
            ha_version = None
            version_sensor = hass.states.get('sensor.ha_version_installed')
            if version_sensor and version_sensor.state not in ['unknown', 'unavailable', 'Unknown', None]:
                ha_version = version_sensor.state

            # Fallback to hass.config if sensor not found
            if not ha_version:
                ha_version = hass.config.version if hasattr(hass.config, 'version') else "Unknown"

            # Get uptime information
            import aiohttp
            import asyncio
            from datetime import datetime, timedelta

            # Get HA uptime
            def get_ha_uptime():
                try:
                    from datetime import datetime, timezone

                    # First try sensor.ha_last_reboot
                    reboot_sensor = hass.states.get('sensor.ha_last_reboot')
                    if reboot_sensor and reboot_sensor.state not in ['unknown', 'unavailable', 'Unknown']:
                        try:
                            # Parse the timestamp
                            reboot_time = datetime.fromisoformat(reboot_sensor.state.replace('Z', '+00:00'))
                            uptime_delta = datetime.now(timezone.utc) - reboot_time
                            days = uptime_delta.days
                            hours = uptime_delta.seconds // 3600
                            minutes = (uptime_delta.seconds % 3600) // 60
                            return f"{days} days, {hours} hours, {minutes} minutes"
                        except:
                            pass

                    # Fallback to sensor.uptime
                    uptime_sensor = hass.states.get('sensor.uptime')
                    if uptime_sensor and uptime_sensor.state not in ['unknown', 'unavailable', 'Unknown']:
                        return uptime_sensor.state

                    return "Unknown (install uptime sensor for accurate data)"
                except:
                    return "Unknown"

            ha_uptime = await hass.async_add_executor_job(get_ha_uptime)

            # Get OS uptime from system
            def get_os_uptime():
                try:
                    import subprocess
                    result = subprocess.run(['uptime', '-p'], capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        return result.stdout.strip().replace('up ', '')
                except:
                    pass

                try:
                    # Windows/psutil alternative
                    import psutil
                    boot_time = datetime.fromtimestamp(psutil.boot_time())
                    uptime_delta = datetime.now() - boot_time
                    days = uptime_delta.days
                    hours = uptime_delta.seconds // 3600
                    minutes = (uptime_delta.seconds % 3600) // 60
                    return f"{days} days, {hours} hours, {minutes} minutes"
                except:
                    return "Unknown"

            os_uptime = await hass.async_add_executor_job(get_os_uptime)

            # Get public IP
            def get_public_ip():
                try:
                    import requests
                    response = requests.get('https://api.ipify.org?format=json', timeout=5)
                    return response.json().get('ip', 'Unknown')
                except:
                    return "Unknown"

            public_ip = await hass.async_add_executor_job(get_public_ip)

            # Get ping results for key services
            ping_results = {}
            ping_names = ['Google DNS', 'Cloudflare DNS', 'Gateway', 'OnOff Automations', 'CF Tunnel']

            # Search for ping sensors dynamically
            for entity_id in hass.states.async_entity_ids('sensor'):
                if 'ping_' in entity_id:
                    sensor = hass.states.get(entity_id)
                    if sensor and sensor.attributes.get('target_name'):
                        name = sensor.attributes.get('target_name')
                        # Check if sensor state is True/False or "True"/"False" or on/off
                        state = sensor.state
                        if state in [True, 'True', 'on', 'On']:
                            ping_results[name] = "‚úÖ Up"
                        elif state in [False, 'False', 'off', 'Off']:
                            ping_results[name] = "‚ùå Down"
                        else:
                            # Try to convert to boolean
                            try:
                                is_up = bool(state) and state not in ['False', 'false', '0', 'off', 'Off']
                                ping_results[name] = "‚úÖ Up" if is_up else "‚ùå Down"
                            except:
                                ping_results[name] = "Unknown"

            # Add "Not Configured" for expected pings that weren't found
            for name in ping_names:
                if name not in ping_results:
                    ping_results[name] = "Not Configured"

            # Get entity counts from individual sensors using exact names
            total_entities = None
            total_automations = None
            integrations = None
            automations_on = 0
            automations_off = 0

            # Use sensor.{title}_total_entities
            title_slug = title.lower().replace(' ', '_')
            entities_sensor = hass.states.get(f'sensor.{title_slug}_total_entities')
            if entities_sensor and entities_sensor.state not in ['unknown', 'unavailable', 'Unknown', None]:
                try:
                    total_entities = int(float(entities_sensor.state))
                except:
                    pass

            # Use sensor.{title}_total_automations
            automations_sensor = hass.states.get(f'sensor.{title_slug}_total_automations')
            if automations_sensor and automations_sensor.state not in ['unknown', 'unavailable', 'Unknown', None]:
                try:
                    total_automations = int(float(automations_sensor.state))
                    if automations_sensor.attributes:
                        automations_on = automations_sensor.attributes.get('active', 0)
                        automations_off = automations_sensor.attributes.get('disabled', 0)
                except:
                    pass

            # Use sensor.{title}_total_integrations
            integrations_sensor = hass.states.get(f'sensor.{title_slug}_total_integrations')
            if integrations_sensor and integrations_sensor.state not in ['unknown', 'unavailable', 'Unknown', None]:
                try:
                    integrations = int(float(integrations_sensor.state))
                except:
                    pass

            # Fallback to manual counting if sensors not found
            if total_entities is None or total_automations is None or integrations is None:
                entity_states = hass.states.async_all()
                if total_entities is None:
                    total_entities = len(entity_states)
                if total_automations is None:
                    automations = [s for s in entity_states if s.entity_id.startswith('automation.')]
                    total_automations = len(automations)
                    automations_on = len([a for a in automations if a.state == 'on'])
                    automations_off = len([a for a in automations if a.state == 'off'])
                if integrations is None:
                    integrations = await hass.async_add_executor_job(
                        lambda: len([d for d in hass.config.components if not d.startswith('_')])
                    )

            # Get top 5 entity domains
            entity_states = hass.states.async_all()
            domain_counts = {}
            for state in entity_states:
                domain = state.entity_id.split('.')[0]
                domain_counts[domain] = domain_counts.get(domain, 0) + 1
            top_domains = sorted(domain_counts.items(), key=lambda x: x[1], reverse=True)[:5]

            # Build health status
            health_status = "Healthy"
            health_color = "#4CAF50"
            health_icon = "‚úÖ"

            issues = []
            if disk.percent >= 90:
                issues.append(f"Disk usage is critically high ({disk.percent}%)")
                health_status = "Critical"
                health_color = "#f44336"
                health_icon = "üî¥"
            elif disk.percent >= 80:
                issues.append(f"Disk usage is elevated ({disk.percent}%)")
                if health_status == "Healthy":
                    health_status = "Warning"
                    health_color = "#ff9800"
                    health_icon = "üü†"

            if memory.percent >= 90:
                issues.append(f"Memory usage is critically high ({memory.percent}%)")
                health_status = "Critical"
                health_color = "#f44336"
                health_icon = "üî¥"
            elif memory.percent >= 80:
                issues.append(f"Memory usage is elevated ({memory.percent}%)")
                if health_status == "Healthy":
                    health_status = "Warning"
                    health_color = "#ff9800"
                    health_icon = "üü†"

            if cpu_percent >= 90:
                issues.append(f"CPU usage is critically high ({cpu_percent}%)")
                health_status = "Critical"
                health_color = "#f44336"
                health_icon = "üî¥"
            elif cpu_percent >= 80:
                issues.append(f"CPU usage is elevated ({cpu_percent}%)")
                if health_status == "Healthy":
                    health_status = "Warning"
                    health_color = "#ff9800"
                    health_icon = "üü†"

            # Create HTML report
            ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: {health_color}; border-bottom: 2px solid {health_color}; padding-bottom: 10px;">{health_icon} Home Assistant Health Report</h2>

<div style="background-color: {'#e8f5e9' if health_status == 'Healthy' else '#fff3e0' if health_status == 'Warning' else '#ffebee'}; border-left: 4px solid {health_color}; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: {health_color};">üìä Overall Health Status</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Status:</td>
            <td style="padding: 8px;"><span style="background-color: {health_color}; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{health_status}</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Report Time:</td>
            <td style="padding: 8px;">{report_time}</td>
        </tr>
    </table>
</div>"""

            if issues:
                ticket_details += f"""
<div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Issues Detected</h3>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">"""
                for issue in issues:
                    ticket_details += f"        <li>{issue}</li>\n"
                ticket_details += """    </ul>
</div>"""

            ticket_details += f"""
<div style="background-color: #f5f5f5; border-left: 4px solid #757575; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #424242;">üíª System Resources</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">CPU Usage:</td>
            <td style="padding: 8px;">
                <div style="background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
                    <div style="background-color: {'#4CAF50' if cpu_percent < 70 else '#ff9800' if cpu_percent < 90 else '#f44336'}; color: white; padding: 4px 8px; width: {cpu_percent}%; text-align: center; min-width: 40px;">{cpu_percent}%</div>
                </div>
            </td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Memory Usage:</td>
            <td style="padding: 8px;">
                <div style="background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
                    <div style="background-color: {'#4CAF50' if memory.percent < 70 else '#ff9800' if memory.percent < 90 else '#f44336'}; color: white; padding: 4px 8px; width: {memory.percent}%; text-align: center; min-width: 40px;">{memory.percent}%</div>
                </div>
            </td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Disk Usage:</td>
            <td style="padding: 8px;">
                <div style="background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
                    <div style="background-color: {'#4CAF50' if disk.percent < 70 else '#ff9800' if disk.percent < 90 else '#f44336'}; color: white; padding: 4px 8px; width: {disk.percent}%; text-align: center; min-width: 40px;">{disk.percent}%</div>
                </div>
            </td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Free Disk Space:</td>
            <td style="padding: 8px;">{disk.free / (1024**3):.2f} GB of {disk.total / (1024**3):.2f} GB</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Free Memory:</td>
            <td style="padding: 8px;">{memory.available / (1024**3):.2f} GB of {memory.total / (1024**3):.2f} GB</td>
        </tr>
    </table>
</div>

<div style="background-color: #e1f5fe; border-left: 4px solid #039be5; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #01579b;">‚è±Ô∏è Uptime & Network Information</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">HA Uptime:</td>
            <td style="padding: 8px;">{ha_uptime}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">OS Uptime:</td>
            <td style="padding: 8px;">{os_uptime}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Local IP:</td>
            <td style="padding: 8px;">{local_ip}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Public IP:</td>
            <td style="padding: 8px;">{public_ip}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Public URL:</td>
            <td style="padding: 8px;">{public_url}</td>
        </tr>
    </table>
</div>

<div style="background-color: #f3e5f5; border-left: 4px solid #9c27b0; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #6a1b9a;">üåê Ping Results</h3>
    <table style="width: 100%; border-collapse: collapse;">"""

            for name, status in ping_results.items():
                ticket_details += f"""
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">{name}:</td>
            <td style="padding: 8px;">{status}</td>
        </tr>"""

            ticket_details += f"""
    </table>
</div>

<div style="background-color: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #1565c0;">üè† Home Assistant Details</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Installed Version:</td>
            <td style="padding: 8px;">{ha_version}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Total Entities:</td>
            <td style="padding: 8px;">{total_entities}</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Total Automations:</td>
            <td style="padding: 8px;">{total_automations} total ({automations_on} active, {automations_off} disabled)</td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Total Integrations:</td>
            <td style="padding: 8px;">{integrations}</td>
        </tr>
    </table>
</div>

<div style="background-color: #f3e5f5; border-left: 4px solid #9c27b0; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #6a1b9a;">üìà Top 5 Entity Domains</h3>
    <table style="width: 100%; border-collapse: collapse;">"""

            for domain, count in top_domains:
                ticket_details += f"""
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">{domain}:</td>
            <td style="padding: 8px;">{count} entities</td>
        </tr>"""

            ticket_details += f"""
    </table>
</div>
{get_ticket_footer(hass, active_entry)}
</div>"""

            response = await client.create_ticket(
                subject=f"{health_icon} Health Report: {title} - {health_status}",
                details=ticket_details,
                priority="Low" if health_status == "Healthy" else "Medium" if health_status == "Warning" else "High",
                contact_id=hass.data[DOMAIN][active_entry.entry_id].get("itflow_contact_id"),
                asset_id=hass.data[DOMAIN][active_entry.entry_id].get("itflow_asset_id"),
                category="Health Report"
            )

            if response.get("success"):
                _LOGGER.info("Successfully sent health report ticket")
            else:
                _LOGGER.error("Failed to send health report: %s", response.get("message"))

        except Exception as err:
            _LOGGER.error("Error sending health report: %s", err, exc_info=True)

    hass.services.async_register(
        DOMAIN,
        "send_health_report",
        handle_send_health_report,
        schema=vol.Schema({
            vol.Optional("include_integration_list"): cv.boolean,
        })
    )

    async def handle_send_backup_check_report(call: ServiceCall):
        """Handle the send_backup_check_report service call."""
        from datetime import datetime

        # Find the first active entry for this integration
        active_entry = None
        for entry_id, entry_data in hass.data[DOMAIN].items():
            if isinstance(entry_data, dict) and "itflow_client" in entry_data:
                active_entry = hass.config_entries.async_get_entry(entry_id)
                break

        if not active_entry:
            _LOGGER.error("No active OnOff Support Agent integration found")
            return

        client = hass.data[DOMAIN][active_entry.entry_id]["itflow_client"]
        if not client:
            _LOGGER.error("ITFlow client not initialized")
            return

        try:
            force_send = call.data.get("force_send", False)
            report_time = datetime.now().strftime("%m/%d/%Y at %I:%M %p")
            title = active_entry.data.get(CONF_NAME, "Home Assistant")

            # Check for backup entities
            backup_status = {}
            backup_issues = []
            overall_backup_status = "Healthy"
            backup_color = "#4CAF50"
            backup_icon = "‚úÖ"

            # Check Home Assistant Cloud Backup
            cloud_backup = hass.states.get('binary_sensor.backups')
            if cloud_backup:
                if cloud_backup.state == 'on':
                    backup_status['Home Assistant Cloud'] = "‚úÖ Active"
                    last_backup = cloud_backup.attributes.get('last_backup', 'Unknown')
                    backup_count = cloud_backup.attributes.get('backups', 0)
                    backup_status['Home Assistant Cloud Details'] = f"{backup_count} backups, Last: {last_backup}"
                else:
                    backup_status['Home Assistant Cloud'] = "‚ùå No Recent Backups"
                    backup_issues.append("Home Assistant Cloud has no recent backups")
                    overall_backup_status = "Warning"
                    backup_color = "#ff9800"
                    backup_icon = "üü†"
            else:
                backup_status['Home Assistant Cloud'] = "‚ö†Ô∏è Not Configured"

            # Check Google Drive Backup addon
            google_backup_sensor = None
            for entity_id in hass.states.async_entity_ids('sensor'):
                if 'backup' in entity_id.lower() and 'google' in entity_id.lower():
                    google_backup_sensor = hass.states.get(entity_id)
                    break

            if google_backup_sensor:
                state = google_backup_sensor.state
                if state not in ['unknown', 'unavailable', 'Unknown']:
                    backup_status['Google Drive Backup'] = f"‚úÖ {google_backup_sensor.attributes.get('friendly_name', 'Active')}"
                    backup_status['Google Drive Details'] = f"Status: {state}"
                else:
                    backup_status['Google Drive Backup'] = "‚ùå Issue Detected"
                    backup_issues.append("Google Drive Backup shows unknown/unavailable status")
                    overall_backup_status = "Warning"
                    backup_color = "#ff9800"
                    backup_icon = "üü†"
            else:
                backup_status['Google Drive Backup'] = "‚ö†Ô∏è Not Configured"

            # Check Local Backups (supervisor)
            local_backup_count = 0
            for entity_id in hass.states.async_entity_ids('sensor'):
                if 'backup' in entity_id.lower() and entity_id.startswith('sensor.'):
                    entity = hass.states.get(entity_id)
                    if entity and hasattr(entity, 'attributes'):
                        count = entity.attributes.get('backups', 0)
                        if isinstance(count, int):
                            local_backup_count = max(local_backup_count, count)

            if local_backup_count > 0:
                backup_status['Local Backups'] = f"‚úÖ {local_backup_count} backups found"
            else:
                backup_status['Local Backups'] = "‚ö†Ô∏è No local backups detected"

            # Don't send if healthy and not forced
            if overall_backup_status == "Healthy" and not force_send:
                _LOGGER.info("Backups are healthy, skipping report (use force_send=true to send anyway)")
                return

            # Create HTML report
            ticket_subject = f"üîÑ Backup Status Report - {title}"
            ticket_details = f"""<div style="font-family: Arial, sans-serif; line-height: 1.6;">
<h2 style="color: {backup_color}; border-bottom: 2px solid {backup_color}; padding-bottom: 10px;">{backup_icon} Backup Status Report</h2>

<div style="background-color: {'#e8f5e9' if overall_backup_status == 'Healthy' else '#fff3e0'}; border-left: 4px solid {backup_color}; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: {backup_color};">üìä Overall Backup Status</h3>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 150px;">Status:</td>
            <td style="padding: 8px;"><span style="background-color: {backup_color}; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">{overall_backup_status}</span></td>
        </tr>
        <tr>
            <td style="padding: 8px; font-weight: bold;">Report Time:</td>
            <td style="padding: 8px;">{report_time}</td>
        </tr>
    </table>
</div>"""

            if backup_issues:
                ticket_details += f"""
<div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Backup Issues Detected</h3>
    <ul style="margin: 10px 0 0 0; padding-left: 20px;">"""
                for issue in backup_issues:
                    ticket_details += f"        <li>{issue}</li>\n"
                ticket_details += """    </ul>
</div>"""

            ticket_details += f"""
<div style="background-color: #f5f5f5; border-left: 4px solid #757575; padding: 15px; margin: 15px 0;">
    <h3 style="margin-top: 0; color: #424242;">üíæ Backup Systems Status</h3>
    <table style="width: 100%; border-collapse: collapse;">"""

            for name, status in backup_status.items():
                ticket_details += f"""
        <tr>
            <td style="padding: 8px; font-weight: bold; width: 200px;">{name}:</td>
            <td style="padding: 8px;">{status}</td>
        </tr>"""

            ticket_details += """
    </table>
</div>
</div>"""

            # Add footer
            ticket_details += get_ticket_footer(hass, active_entry)

            # Create ticket
            response = await client.create_ticket(
                subject=ticket_subject,
                details=ticket_details,
                priority="Medium" if backup_issues else "Low",
                contact_id=hass.data[DOMAIN][active_entry.entry_id].get("itflow_contact_id"),
                asset_id=hass.data[DOMAIN][active_entry.entry_id].get("itflow_asset_id"),
                category_id=41,
                status="7",
                assigned_to=4
            )

            if response.get("success"):
                _LOGGER.info("Successfully sent backup check report")
            else:
                _LOGGER.error("Failed to send backup check report: %s", response.get("message"))

        except Exception as err:
            _LOGGER.error("Error sending backup check report: %s", err, exc_info=True)

    hass.services.async_register(
        DOMAIN,
        "send_backup_check_report",
        handle_send_backup_check_report,
        schema=vol.Schema({
            vol.Optional("force_send"): cv.boolean,
        })
    )

    async def handle_get_contacts(call: ServiceCall):
        """Handle the get_contacts service call to retrieve all contacts."""
        client = hass.data[DOMAIN][entry.entry_id]["itflow_client"]
        if not client:
            _LOGGER.error("ITFlow client not initialized")
            return

        try:
            response = await client.get_contacts()

            if response.get("success"):
                all_contacts = response.get("data", [])
                # Filter out contacts with name "*****"
                contacts = [
                    contact for contact in all_contacts
                    if contact.get("contact_name") != "*****"
                ]
                _LOGGER.info("Retrieved %d contacts from ITFlow (excluding hidden contacts)", len(contacts))

                # Log each contact for easy reference
                for contact in contacts:
                    contact_id = contact.get("contact_id")
                    contact_name = contact.get("contact_name")
                    contact_email = contact.get("contact_email", "N/A")
                    _LOGGER.info("Contact: ID=%s, Name=%s, Email=%s", contact_id, contact_name, contact_email)

                # Store in hass.data for access by automations
                hass.data[DOMAIN][entry.entry_id]["contacts_list"] = contacts
            else:
                _LOGGER.error("Failed to retrieve contacts: %s", response.get("message"))
        except Exception as err:
            _LOGGER.error("Error retrieving contacts: %s", err, exc_info=True)

    hass.services.async_register(
        DOMAIN,
        "get_contacts",
        handle_get_contacts,
        schema=vol.Schema({})
    )





async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    # Unload all platforms
    platforms_to_unload = [Platform.SENSOR, Platform.BUTTON]

    unload_ok = await hass.config_entries.async_unload_platforms(entry, platforms_to_unload)
    if unload_ok:
        # Close ITFlow client if it exists
        entry_data = hass.data[DOMAIN].get(entry.entry_id)
        if entry_data and isinstance(entry_data, dict):
            client = entry_data.get("itflow_client")
            if client:
                await client.close()

        hass.data[DOMAIN].pop(entry.entry_id, None)
        active_entries = hass.data[DOMAIN].setdefault("active_entries", set())
        active_entries.discard(entry.entry_id)
    return unload_ok
